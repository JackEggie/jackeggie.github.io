{"pages":[{"title":"About","text":"热爱生活，热爱编码。分享生活中的美好时光。 Who am I?🐵程序员 / 🐱铲屎官 / 🍧美食分享 / 🖥技术分享 公众号ID：jack_eggie 即刻/Jellow APPID：蛋蛋卷丶","link":"/zh-cn/about/index.html"}],"posts":[{"title":"Java 中 int 类型的二进制表示","text":"原理可通过 Integer.MAX_VALUE 和 Integer.MIN_VALUE 查看 int 类型的最大和最小值，分别为 0x7fffffff(2^31-1) 和 0x80000000(2^31)，其中 0 即为 0，正数的最高位为 0，负数的最高位为 1。 Java 中负数的表示方式为正数的补码（例：原码 00，反码 11，补码 00，补码的计算方式为反码加一，此处丢弃溢出位）。采用这种方式的原因是 0 的交叉（zero crossing）问题，即 0 和 -0 需要用同一种方式表示，见补码计算例子。如果采用反码表示负数的话，0 就会有两种表示：所有位全为 0、所有位全为 1。 因此 Java 中 0 的所有位全为 0，1 为 0000…0001，-1 的所有位全为 1，Integer.MAX_VALUE 为 0111…1111，Integer.MIN_VALUE 为 1000…0000。 注意事项在 Math.abs() 的文档中可以看到如下文字： 1Note that if the argument is equal to the value of &#123;@link Integer#MIN_VALUE&#125;, the most negative representable &#123;@code int&#125; value, the result is that same value, which is negative. 由上述原理可知，由于 Integer.MIN_VALUE 首位为 1，则其为负数，因此 Math.abs() 会取其相反数。而相反数的运算方式为补码，1000…0000 先取反得到 0111…1111，再加一，则循环回到自己 1000…0000。因此在对 Integer.MIN_VALUE 取相反数时永远会得到自己。 来源LeetCode 7. Reverse Integer 中的一个 Integer.MIN_VALUE 的 test case。","link":"/zh-cn/binary-form-of-int-in-java/"},{"title":"缓存框架调研","text":"Redis简介：结构化数据存储服务。由客户端提供一系列api（command）来访问数据。支持分布式存储。 开源：C语言 jsr107：不支持 ssl加密：支持 sql查询：rediSQL – 500+ stars 事务：MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。 数据分区：固定为16384个slot java原生数据类型：redis只支持自己提供的数据类型，String，Hash，Set，List，Zset 二级缓存支持：不支持 事件通知：publish、subscribe命令 持久化：rdb、aof 客户端api：jedis、redisson Ehcache简介：进程内缓存框架，基于java开发，支持分布式存储，支持进程外存储。 开源：Java jsr107：支持 相关资料 ssl加密：不支持 sql查询：不支持 事务：JTA事务支持 数据分区：只存储local cache，分布式调用各自server上面的缓存数据 java原生数据类型：与java原生数据类型兼容，本质上存储的都是Object 二级缓存支持：无相关概念 事件通知：CacheManagerEventListener和CacheEventListener接口 持久化：磁盘 客户端api：ehcache Hazelcast简介：集群化分布式内存存储平台。 开源：Java jsr107：支持 ssl加密：商用版支持 sql查询：仅提供有限的支持(只有几个关键字) 事务：不支持 数据分区：271个partition java原生数据类型：提供了set、map、list等数据类型 二级缓存支持：无相关概念 事件通知：CacheManagerEventListener和CacheEventListener接口 持久化：商用版支持 客户端api：hazelcast-client Ignite简介：基于内存的分布式数据库，缓存，计算平台。 开源：Java jsr107：支持 ssl加密：支持 sql查询：支持 事务：支持 数据分区：一致性hash java原生数据类型：支持 二级缓存支持：客户端缓存 事件通知：IgniteEvents 持久化：可集成外部数据源（db、nosql等） 客户端api：ignite 总结Redis使用最广泛，但是源码是C语言写的，修改原生功能相对困难。 Ehcache的免费版仍然着眼于单机的缓存模式，集群化的实现相对困难，而收费版在集群化，堆外存储，持久化上面已经和市面上的大多数缓存框架功能一致了，远程调用和集群分片的模式较为成熟。 Hazelcast和ehcache的收费版较为相像，但是更为灵活，数据同步的方式（同步/异步复制），副本集的数量，分片的存储方式都是可配置的。集群高可用的算法利用的是集群最老的节点保存的分区表。 Ignite提供的功能更为强大，但是使用的公司相对较少。Ignite的设计是为了方便做内存计算，单纯的存储（尤其是持久化）会显得不太方便。比较亮眼的功能有对等类加载。","link":"/zh-cn/cache-framework-research/"},{"title":"本博客搭建过程","text":"前言本文章基于Windows 7+git version 2.14.1.windows.1+NodeJS v6.11.4+hexo-cli 1.0.3，不同平台和版本的搭建过程可能略有差异。 准备工作安装Git下载并安装Git。 检验安装成功：1git --version 安装Node.js下载并安装Node.js。 检验安装成功：1node -v 安装Hexo在Git Bash中输入以下命令安装Hexo：12npm install hexo-cli -gnpm install hexo --save 创建博客创建博客目录123hexo init jackeggie.github.iocd jackeggie.github.ionpm install 生成静态页面12hexo cleanhexo generate 运行本地web服务1hexo server 在浏览器中打开localhost:4000即可看到运行效果。 发布一篇文章创建一篇新的文章1hexo new &quot;文章名称&quot; 在source_posts目录下即可看到刚才创建的文档，在该文档中编写文章内容，文章采用markdown语法进行排版。 发布文章关于Git Pages的创建请参考这里。 1hexo deploy 执行完上面的命令以后即可在Git Pages上面看到自己的博客了。 个性化本博客使用的是NexT主题，更多主题可以到Hexo 主题库下载。请参考NexT 的文档完成主题的安装与配置。 博客的管理在Git Pages的仓库创建一个Hexo分支来管理博客的配置以及归档文件，即可实现多平台管理博客。 参考内容Hexo 博客搭建指南SylvanasSun’s Blog","link":"/zh-cn/create-a-blog/"},{"title":"对于情绪管理的思考","text":"前言一直以来，自己的情绪一直是个问题，很容易就大动肝火。不顾后果地发脾气很容易伤了身边的人又伤了自己。所以去找了一些资料，让自己学习如何管理自己的情绪。 认识情绪情绪这东西甚至说不上是个抽象的概念，大概连个具体的定义也没有吧。但是普通人还是很容易理解什么是情绪，什么是开心的情绪或者是不开心的情绪。这大概就是理科和文科学习上的区别。 我们表露出来的情绪，需要我们自己去正视它，不要把情绪理解为好与坏。情绪本身没有好坏之分，只是人对外部世界的某些刺激做出的正常反应而已。也许有些同学已经明白了，情绪就是应激的一部分。 有的人会选择压抑情绪，有的人则会选择宣泄情绪。但是其实能把情绪表露出来，也算是某种程度上的自由意志的体现。渴望自由的人会倾向于表达，而崇尚节律的人会倾向于抑制。 情绪管理的必要性情绪占据大脑的时候人总会做出一些超越理性的行为，而且往往事后会较为后悔。为了避免这种情况的发生，我们需要了解并学着管理自己的情绪，让理性占据上风。 另外值得一提的是，情绪管理力的缺失还是和现代的教育有很大的关系。小孩子成长的过程中我们太重视理论知识的教育了，很多家长都忽视了要教小孩子怎么做人，怎么处理自己与社会的关系，怎么处理自己内心的感觉。 管理情绪理论与实践有很大的差异，因此这里提供的方法仅作为参考，具体如何处理自己的情绪因人而异。 疏导人每天都有冷静的时候和兴奋的时候。冷静的时候需要让自己保持冷静，兴奋的时候则要尽量让自己释放出内心的感觉。让情绪释放出来的管道疏通，就不太容易产生情绪上的问题。 但也不能完全放纵自己的情绪释放，在很多时候也要适当地压抑自己的情绪，在合适的场景下再去释放。例如，在上班开会的时候，有一些会让你很兴奋的事情发生，这就需要抑制自己的情绪，等开完会以后再释放比较合适。要合理地与自己的情绪做斗争，让情绪保持松紧有度。 尝试改变认知有时候情绪会误导我们，或者说某些错误的认知会让我们产生错误的情绪。这时候我们需要静下心来，让自己尝试从其他角度去窥的事情发展的真面目。简单地说，发脾气也要三思而后行。 同样地，对环境的认知也是一样的，需要认真考虑所处的环境，不能不顾环境，对环境带有错误的认识而认为情绪的产生是环境的问题。 在外界对自己产生情绪干预的时候，也要多想想自己产生情绪的原因，而不要把责任都归咎于外界，归咎于别人。在这个世界上活着，自己才是主体，需要自己来掌控属于自己的情绪。 静心如果有段时间觉得自己特别容易激动、情绪化，那么则需要考虑让自己多多静下心来做事，或者静下心来思考。也就是说，要保持一刻平常心。其实这世界上没有什么是不合理的，存在即合理，也就没有什么好不开心的，只是需要学着接受而已。 当然，不仅仅要学着接受这个世界，也要学着接纳自己。自己产生的开心或不开心，都是自己的一部分，都是自己正常的生理心理反应。要正视自己，开心了就笑，不开心就哭，正常释放即可。 如若觉得有特别强烈的情绪的时候，又不适合立即发泄，那么也可以考虑做一些其他事情暂时转移注意力。做的事情一定要可以让自己在一段之间内保持专注力，不考虑事情以外的情况，事后再来考虑如何宣泄情绪。","link":"/zh-cn/emotion-management/"},{"title":"Gitflow工作流示例","text":"前言本文演示了如何用Gitflow来管理单个发布循环。 初始化中央仓库这时，Git会为你默认创建一个master分支，将你的最初的项目代码提交到master分支上。 创建开发分支从master创建一个develop分支，并将其push到服务器上。并让团队中每个成员都建立该分支的本地拷贝。develop分支将会包含项目的全部历史提交，而master分支可能只包含部分历史提交。 开始开发新功能Jack需要基于develop分支拉取feature1分支，并在该分支上面进行新功能的开发。 完成新功能开发Jack提交了所有代码到分支feature1上之后，将feature1分支合并到develop分支，解决冲突并推送到中央仓库。这里需要在合并前确保本地的develop分支是最新的。 发布新功能Jack确定了发布的版本号为0.1，并且从develop拉了一个发布分支release-0.1，在发布过程中产生的问题都会提交到这个分支上，发布前执行测试和创建release note也都会基于这个分支来做。这里做到了所谓的发布前的代码冻结的作用。 完成发布Jack完成了0.1版本的发布，并且把release-0.1分支合并到master分支上，同时在master分支上提交了0.1版本的tag。并把master分支合并到develop分支上。 这时，一个新功能的开发和一个新版本的发布已经完成。下面来看一下hotfix的流程。 发现bug并进行hotfixJack从master拉取了一个hotfix-issue-001分支，并且对issue-001进行修复。 发布hotfixJack发布了hotfix-issue-001分支，并将其合并回master分支。然后再将master分支与develop分支进行合并。 这时，一个hotfix的发布已经完成。 上面所列举的Gitflow的用法只是使用过程中的某种特例，并不是所必须要遵守的规定。我们在使用Gitflow的过程中，需要大胆地对Gitflow的用法做取舍，以满足项目管理的健壮，完备和简洁。 后记简化这里提供一种简化Gitflow的思路，适用于小型开发团队。master分支与develop分支可以在同时开发的功能较少时进行简化，只使用master分支，略去develop分支。feature分支与release分支可以在开发人员较少时进行简化，只使用feature分支，略去release分支。 扩展 在并行开发的功能较多时，需要特别为发布计划和代码merge建立管理制度，以防止不同的功能之间冲突过多而花费大量时间。 在开发人员较多时，可以采用在feature分支的基础上在拉取类似于feature-jack的个人开发分支，以减少开发过程中的冲突。 针对有较为严格code review规定的团队，可以采用pull request来进行code review。 所有的团队都需要注意，定时清理不需要的分支。 所有的团队都需要注意，需要制定严格的分支名称的规则。","link":"/zh-cn/gitflow-example/"},{"title":"Hexo图片引用问题","text":"前言使用Hexo创建博客很方便，但是图片的管理是一件很头痛的事情。最开始想要使用图床的方式来引用图片，但是止于图床中图片管理不易和难以寻找一个稳定的图床。后来发现了Hexo原生支持的图片引用方式，Github地址 hexo-asset-image的使用开启post_asset_folder在博客的_config.yml配置中将post_asset_folder置位true。 1post_asset_folder:true 打开上述开关后，在使用Hexo创建新文章时会自动创建一个同名的空文件夹，与该文章相关的所有静态资源都可以放到该文件夹中，以方便在文章中直接引用。 安装hexo-asset-image插件在Hexo目录下执行如下命令： 1npm install hexo-asset-image --save 在文章中引用图片这里直接使用相对路径引用图片： 1![](测试图片.jpeg)插入图片测试： 可以看到，上面显示的图片生成的html中使用的是图片的绝对路径地址，而不是相对路径。 后记本文所记述的引用图片的方式旨在解决博客图片的管理问题，和图片的引用在主页或者其他页面展示不正确的问题。 与上文记述的不同的是，Hexo3提供了新的标签插件来解决文章中资源引用的问题： 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 笔者在尝试Hexo3的标签时出现了一些错误还未解决，因此暂不演示该种方式来引用图片。","link":"/zh-cn/hexo-pic/"},{"title":"搜索引擎技术的简介","text":"什么是搜索引擎？日常生活中的搜索引擎搜索引擎是一种用来在互联网上搜索信息的应用程序。当然，现在说是应用程序已经不太确切了，称为服务会更准确一些。像 Google、Baidu 等互联网搜索引擎人们都已经习以为常。通过搜索引擎，人们可以很轻松方便地从网络上查找到自己需要的资源，很难以想象没有搜索引擎的时代人们需要怎样去获取信息。 搜索引擎 VS 数据库同样提供存储和查询功能，但是搜索引擎和数据库在设计理念和工作方式上差异还是非常大的。数据库的功能更为的全面，是一种通用的数据存取引擎，搜索引擎则重点处理大数据量的文本数据，并且只侧重于获取数据的性能和方式。 索引数据库通常使用 like 关键字来进行文本匹配，然而这在长文本中效率很低。当然你也可以对需要搜索的字段建立索引，可是数据库中你不能对所有潜在的搜索字段都建立索引。 数据结构数据库使用 B 树来建立索引，这是一种平衡搜索树，查找到所有的条目的速度都相同。而搜索引擎采用的数据结构是倒排索引，这在后文会进行介绍。 设计理念设计理念的不同导致了功能上的部分差异。数据库的优势在于表与表之间的关系，而搜索引擎几乎不支持任何跨索引查询。数据库在使用上读写两端都同样重要，而搜索引擎则完全侧重于获取数据的方式上。 搜索引擎的历史最早的搜索引擎诞生于 1987 年，名叫 Archie（/‘ɑ:tʃi/），是加拿大魁北克省蒙特利尔的麦吉尔大学的一个志愿者团队制作的。它最初的目的只是提供一个互联网上 FTP 资源的检索功能，是利用 grep 命令来实现的。到了 1990 年，Archie 经过了一次升级，升级后可以使用 telnet 来访问搜索服务了，并且有了最初的 web 界面。 在最早的搜索引擎出现之后，互联网上的资源渐渐丰富起来，人们对于高效地搜索互联网上的资源渐渐有了需求。到了1995年，Yahoo 公司率先开展了搜索引擎业务。虽然搜索引擎的业务发展在当时还并不理想，但是带动了互联网行业做搜索引擎的趋势。在那之后，1998 年和 2000 年，Google 和 Baidu 相继开展了自己的搜索引擎业务，真正将将搜索引擎普及到寻常百姓家中。在 2009 年，Microsoft 公司才反应过来，推出了 Bing 搜索，但行业中可以分的利益已经不多。 到现在，Google 已经成为了世界上最受欢迎的搜索引擎，与其他互联网搜索引擎相比，占有 90% 以上的访问量，其次是 Bing 和 Baidu。但在不同的地区，搜索引擎的偏好还是存在很大的差异，在俄罗斯，Yandex 是最受欢迎的搜索引擎，在中国，则是 Baidu 最受欢迎，在韩国最受欢迎的是 Naver，在日本和台湾则是 Yahoo。 全文搜索前文所提到的都是广义上的搜索引擎，在搜索引擎技术的研究中，注意研究全文搜索技术。区别于元数据搜索和数据库搜索，全文搜索侧重于大数据量的文本检索技术。 LuceneLucene 是 Java 实现的全文检索工具包，由 Doug Cutting 所编写（Doug Cutting 创立了 Lucene 和 Nutch，也是 Hadoop 的奠基人之一）。Lucene 在全文检索技术中已经成为了一个标杆，它被翻译成多种语言，以便在不同的环境中被使用。其中建立倒排索引的方式和使用的 TF-IDF 文档打分算法被业界公认为是搜索技术的行业标准。 Solr &amp; ElasticsearchSolr 和 Elasticsearch 都是基于 Lucene 的全文检索平台，利用他们可以搭建完整的搜索服务。由于 Elasticsearch 可以方便地和可视化工具做集成，现在 Elasticsearch 更受欢迎，通常Elasticsearch会被用来做系统日志的收集和管理。 搜索引擎中的关键技术索引技术不同于 grep 命令的顺序扫描和数据库的平衡搜索树，搜索引擎通常采用的是倒排索引的结构。倒排索引通常指关键字和其所属文档的对应关系，在代码中以基本的 keyword -&gt; { doc1, doc2, doc3… } 来实现。 搜索技术对于海量的原始数据而言，除了需要倒排索引技术的帮助之外，还需要一些特定的搜索技术来完善搜索功能。最为迫切的需求无非是如何把用户想要的结果返回给用户，也就是文档排序问题。 TF-IDF这里引出一种名为 TF-IDF 的算法来帮助搜索引擎做排序工作。 TF（Term Frequency）指文档中某个词出现的频率。 DF（Document Frequency）指包含某个词的文档的数量。IDF 即为该值的倒数。 一个经典的 TF-IDF 值的计算公式为 weight = tf * sqrt(n / df)。 TF-IDF 的思路来自于词和文档的关系。文档中某个词出现的越少，则文档和该词的关联越小。而若某个词被大量文档包含，则认为该词更为通用，不是一个可以和某文档关联的词。 VSM（Vector Space Model）这就是我们常说的向量空间模型。在向量空间模型中，两个向量的夹角越小，则认为其相关性越大。我们用文档中所有词的词频（权重）组成向量，来计算文档之间的余弦值或者是文档与查询条件之间的余弦值。 其他技术爬虫爬虫是搜索引擎获取数据的重要组成部分，但也通常被人们忽视。原因可能是其相对较低的技术含量，亦或是其多样化的实现方式。 爬虫可以比人类更快地获取数据。要实现一个爬虫，首先即要考虑的是并发的问题。分布式通常是解决并发量的一个方案。但要小心，并发量提升之后也通常会对爬取的站点带来请求的压力。因此，若需要开发爬虫，则必须要遵守每个站点的robots.txt中制定的规则，这已然成为了爬虫必须要遵守的礼仪规范。 分词为了提升搜索的效率，对文档的预处理是非常重要的。而分词则是处理文档的第一步。 英文的分词是天然由空格形成的，而对于东方的“方格字”，分词就显得很难了。现在应用得最多的分词方式即是基于字典的分词：正向最大匹配法、逆向最大匹配法和双向最大匹配法。 结语搜索引擎的技术是一门很深的学问，并且在近年来还处在高速的发展中。虽然现如今如谷歌、阿里等大厂的搜索相关的技术已经较为成熟，但很多技术仍然处于瓶颈中，亟待突破性的发展。","link":"/zh-cn/intro-to-search-engine/"},{"title":"Java内存结构","text":"概述Java内存模型是JVM与计算机内存协同工作的规范与准则。Java虚拟机中的线程与内存结构和计算机的CPU与主存的架构并不相同，因此才需要一套规则来整合两种模型来协同工作。 这套规则描述了线程间共享变量的可见性和多线程访问带来的冲突等问题。 原始的Java内存模型天生存在一些不足之处，因此在JDK1.5之后做了重新修订。 多线程下的Java内存结构我们已经了解了Java的内存结构主要被分为线程栈和堆。线程栈中存放的变量只在该线程内部可见，且各线程间均只可见自己线程栈中的变量。堆中存放的都是线程间共享的变量，对所有线程均可见。 额外需要说明的是，如果线程中的变量是引用类型的，则被引用的对象是被分配在堆上的。同样地，对象所有的成员变量，包括静态的成员变量，都是被分配在堆上的。 硬件内存架构硬件的内存架构与JVM的内存结构从设计上就是不同的。 计算机的核心是CPU，通常一台计算机都会有多个CPU，那么多线程情况下，通过多个CPU的同时执行，线程将会出现并发的情况。 计算机的运行时存储单元主要是主存，或者称为内存。主存与CPU之间的数据交互会通过多级缓存和CPU寄存器。在这些存储单元中的数据对CPU来说都是共享的。 CPU执行任务时的典型数据流向通常是这样的：从主存读取部分数据到多级缓存中，再从多级缓存把数据写入CPU寄存器中，CPU从寄存器中取出数据进行计算，并将计算结果写入寄存器，寄存器再把数据刷回多级缓存中，多级缓存再把数据刷回主存。 Java内存结构与计算机硬件架构的协同工作两种架构的差异主要在于线程栈和堆在硬件架构中是混杂在主存、多级缓存和寄存器中的。 接下来我们来看看这种架构上的差异会导致什么问题。 可见性可见性问题的产生主要由多级缓存以及寄存器的存在引起。 通常，CPU在读取数据时，会逐层检查数据是否存在在寄存器、多级缓存、主存中，如果存在，会直接获取。而CPU写入数据时，则只会把数据写入到寄存器中。寄存器到多级缓存以及主存的刷回是由操作系统来执行的，执行的频率不可预知。 在多线程任务执行时，多个线程由多个CPU并发执行，数据的交互可能仅与各CPU的寄存器有关，此时就会出现可见性问题。 举个例子，count++这样的代码在多线程执行时，由于可见性问题，会出现得到的结果比预期结果小的情况。这样的结果原因如下，一个线程从主存中取count的值时，另一个线程加一的结果还没有写回主存，这时，当前线程获取到的count原始值是比预期值小于1的。 解决上述问题最合适的方案是使用volatile关键字。在Java 1.5以后，volatile关键字会保证用该关键字修饰的变量在写入时都会刷新到主存中，以保证任何时刻任何线程从主存中获取到的值都是正确的。 条件竞争（Race Condition）条件竞争是指多线程对某个资源的访问没有被正确同步，没有被正确同步的概念通常指多线程下对同一个资源的读写存在竞争，即读写的顺序没有在逻辑上被指定。 同样举例count++这句代码，在多线程执行时，由于没有指定读写的顺序（这里的加一操作不是原子操作，编译后会产生读取和写入两个操作），我们考虑线程1读，线程2读，线程1写，线程2写这样的顺序。由于线程1和2都读到的是count的原始值，两个线程分别加一之后写入，得到的仅仅是加1之后的结果，而预期是加2之后的结果。这就是典型的条件竞争问题。 解决条件竞争最基本的方案是使用synchronized关键字来修饰需要同步的代码块，该关键字能保证同一时刻只能有一个线程能执行该代码块中的操作，并且退出代码块时，所有被更新的变量都会刷新回主存。这样就能保证没有其他线程的代码会插在被同步的代码之间执行了。","link":"/zh-cn/java-memory-module/"},{"title":"Json解析器性能对比","text":"前言在两年前曾经做过四种Json解析器的性能对比，现在回头看当时的结果，跟当时的想法还是有很大差异的。 Json-lib、Gson、Jackson、Fastjson性能对比测试环境如下： 1234操作系统：Windows 7 专业版 64位CPU：Intel(R) Core(TM) i5-6200U CPU @2.30GHz内存：16GJava：1.7.0_13 测试代码 测试结果： // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts1126')); // 指定图表的配置项和数据 var option = { tooltip : { trigger: 'axis' }, legend: { data:['json-lib parse','json-lib serialize','gson parse','gson serialize','jackson parse','jackson serialize','fastjson parse','fastjson serialize'] }, calculable : true, xAxis: { name: '解析次数', type: 'category', data: ['100', '10000', '1000000'] }, yAxis: { name: '平均耗时（纳秒）', type: 'value' }, series : [ { name:'json-lib parse', type:'line', data:[1150503, 134553, 23120] }, { name:'json-lib serialize', type:'line', data:[2457357, 76311, 8265] }, { name:'gson parse', type:'line', data:[93331, 10460, 1507] }, { name:'gson serialize', type:'line', data:[478135, 13784, 1827] }, { name:'jackson parse', type:'line', data:[529801, 19331, 1257] }, { name:'jackson serialize', type:'line', data:[592914, 20638, 757] }, { name:'fastjson parse', type:'line', data:[165378, 12620, 1098] }, { name:'fastjson serialize', type:'line', data:[1206866, 13132, 798] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 结论就测试结果来看，性能上Fastjson和Jackson是胜出的，同时也能印证序列化和反序列化的性能不能同时达到最优，要提升其中之一的性能，就必然会牺牲另外一方。 但是json解析的性能就这么重要吗？让我们再从使用的角度比较一下这两家的产品。 编码风格Jackson出自FasterXML，并且广泛被老外使用，编码风格不用多说。 Fastjson相对来说，使用没有那么广泛，隐藏bug较多。另外类似于序列化配置中出现的硬编码较多。最重要的一点是，Fastjson所推崇的通过大量使用String.substring()方法来避免内存分配，以提高性能的方式，有内存泄露的隐患，而且在JDK1.7以后，该方法仍然会重新申请内存，性能优势不再。 可定制性仍然是由于使用广泛度的原因，Jackson的可定制性相当强，可以说什么奇奇怪怪的要求都能满足，或者说都有前人已经做好了工作给后人了。而Fastjson仅仅只能通过SerializeFilter类来新增自己的扩展功能，相对来说较为麻烦。 文档这一点就不吐槽了，阿里开源的产品貌似文档都一般，比较简单不够详细。这可能和阿里对开源的产品还不够重视有关。 在Json解析器的使用上，性能通常不是最关键的因素，但仅仅性能优秀肯定是不够的。总之，这番对比下来，还是选择Jackson最为靠谱。","link":"/zh-cn/json-parser-performance/"},{"title":"JVM内存结构","text":"JVM内存结构概述在开发过程中经常会遇到的堆内存的概念具体是什么？常量池在JVM中的内存区域是怎么管理的？遇到OutOfMemory异常应该如何处理？ 平时对上述问题可能只有一个模糊的概念，本文将会详细地介绍JVM的内存结构，让上面问题的答案变得清晰明了。 JVM的内存结构主要分为堆内存、方法区和栈三大块。而堆内存又分为新生代和老生代。方法区存储的信息为常量、类信息和静态变量等。栈分为程序计数器、JVM方法栈和本地方法栈。堆和方法区是线程共享的内存区域，而栈是线程的私有内存区域。 JVM内存参数这里盗用一张图来展示JVM的内存结构和参数信息。 -Xms：堆的最小占用空间-Xmx：堆的最大占用空间-XX:NewSize：新生代的最小占用空间-XX:MaxNewSize：新生代的最大占用空间-XX:PermSize：永久代（方法区）的最小占用空间-XX:MaxPermSize：永久代（方法区）的最大占用空间-Xss：每个线程的栈的占用空间 堆空间堆是JVM管理的最大的一块内存区域，几乎所有的对象在创建的时候，都会在这里进行内存分配。平时我们所说的垃圾回收的工作就是在这里进行的，常用的垃圾回收算法都是基于分代回收的算法，因此堆空间可以分为新生代和老生代，新生代还可以分为Eden区、From Survive区和To Survive区。 堆可以处于物理不连续的内存空间上，和磁盘的管理一样，只需要保证逻辑上的连续就可以。并且堆的大小是可扩展的，以保证操作系统内存分配的灵活性。 新生代新生代是所有对象被初始化分配内存的地方，当有对象不再被引用的时候，Minor GC线程就会来把这一块内存回收掉。 老生代当有对象在经历了几次Minor GC之后仍然存活，就会被移动到老生代中。或者虚拟机在分配占用内存较大的对象的时候，会直接在老生代中分配内存。Full GC会清理并回收老生代的内存。 方法区方法区用于存储JVM的类信息、编译后的代码、常量和静态变量等数据。方法区和堆空间一样，都是内存共享的区域，也同样不需要连续的内存，大小也可扩展。 方法区的特殊性在于，用户可以选择不在该区域进行垃圾回收，因此该区域也可被称为永久代。但通常来说，该区域的垃圾回收仍然是必要的，只是如何提升该区域的垃圾回收效果至今仍是一个较为困难的问题。 常量池在class文件被加载到JVM中时，基础数据类型的常量会被加载到运行时常量池中。 静态数据池静态数据池包括静态的变量和方法，以及静态的代码块。 编译后的代码池这里保存着class文件的内容。 本地内存区本地内存区由程序计数器、虚拟机栈和本地方法栈组成。这块区域是线程私有的。 程序计数器顾名思义，程序计数器是程序运行的行号指示器。线程在执行时的逻辑循环、分支与跳转都通过程序计数器所标记的数据来执行。在多线程工作时，每个线程都有自己独立的程序计数器，保证一个CPU在同一时刻只会执行一个线程中的一个指令。 如果线程执行的是Java方法，程序计数器记录的是编译后的虚拟机字节码指令的地址，而如果执行的是Native的方法，则计数器记录空值。 这是JVM中唯一不会抛出OutOfMemory异常的区域。 虚拟机栈与程序计数器相同，虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机栈存储的是线程中的方法的局部变量、方法出入口等信息。 虚拟机栈会抛出两种异常。当栈的深度超出JVM所规定的深度时，会抛出StackOverFlow异常。当请求栈的大小超出JVM所规定的内存大小时，会抛出OutOfMemory异常。 本地方法栈本地方法栈与虚拟机栈基本是类似的，只是本地方法栈存储的是Native方法的局部变量和方法信息。 堆外内存除了JVM所管理的内存区域之外，JVM也可以访问操作系统直接管理的内存区域，这被称为堆外内存或者直接内存。使用堆外内存的好处在于，脱离了JVM的管理，不受GC线程的影响，并且在IO操作时会有更好的性能。 堆外内存可以通过java.nio.ByteBuffer的allocateDirect方法来创建。但是在不使用后需要及时回收，否则造成内存泄漏会难以排查。使用时也要注意存储的数据不要过于复杂，或者数据仍然需要参与内存计算。堆外内存性能好在于可以少拷贝一次内存，直接进行IO，如果需要参与内存计算，则还需要把数据拷贝到JVM中，增加开销。","link":"/zh-cn/jvm-memory-structure/"},{"title":"聊聊我的第一次心理咨询体验","text":"背景从去年开始筹备婚礼之后，自己的情绪就变得逐渐“难以控制”起来。在以前，即使偶尔和父母有矛盾，也仅仅只是不开心，很少有能够影响好几天的情况发生。而现在，一旦因为某些事情不顺心，可以被悲观的情绪影响好多天。被消极的想法支配的感觉真的很不好。 在被悲观情绪支配的情况愈演愈烈之后，我极度想要做出一些改变。 改变首先，我认为人是很难改变其他人的所做和所想的。基于这一点，我决定改变还是要从自身入手。 我最开始尝试的是去说服。这种方式在现在看来是完全错误的，事实也印证了这一点。我与父母沟通的时候，我越是想要去说服他们，他们便越不认同我的说法。最后矛盾被激化，我得到的答案变成了“我不听话，是个不孝子”。 在失败的尝试过后，我决定有矛盾的时候，尝试着让自己去排解不好的情绪。把问题放任，用时间去解决问题。同样地，得到的结果仍然很不好。除了大多数问题是时间无法冲淡的之外，更严重的是情绪非常难以排解。我常常在排解的过程中陷入非常大的痛苦中。 尝试这样的痛苦持续了将近一年的时间。而现在我想要寻求一些专业的帮助，能够给我一些生活上的指引和转变，让我重新快乐起来。 也曾经在网上查找过专业的心理咨询机构，看到网上的评价寥寥无几，并且评价都较为一般，便不太相信那些所谓的心理咨询机构。也找过一些医院的精神科室的资料，但医院好像都只接受精神状态特别不正常的病人，其治疗手段也都比较粗暴，鲜有“吃力不讨好”的咨询的方式。 前段时间在豆瓣上看到了某公益心理组织有心理咨询的体验活动，便萌生了去试试的想法。我知道自己的情况并不严重，或许只是某种思路上的错误让自己走不出来。这与那些需要长期咨询治疗的情况不同，也许只需要有一位专业人士给我“指点迷津”，我便能“豁然开朗”。 体验在报名之后等了约一周多的时间，即使不太清楚这样的公益组织是如何运作的，我的耐心也在逐渐被消磨。慢慢地，我想是不是这种非营利性的活动会更加不靠谱呢？ 但是在收到反馈的时候我是惊喜的。我想我可能找到了国内心理咨询的正确打开方式了。 时间约在了周末的下午，一个办公楼的星巴克内。这样的时间和选址让我基本确定了这个公益活动的性质，我是感到比较惊讶的。时间其实不必多说，只是为了选择咨询师和体验者都方便的时间，并且周末的时间会更加宽松，如果有任何意外的情况都会比较好处理。而地点就比较有意思，选在了周末没有人上班的办公楼的星巴克内。这个地点有两个属性，公众场合和人流量少。这两个属性都在一定程度上给了体验者些许安全感。唯一的缺点是，就算是周末办公楼的星巴克，也是比较吵闹的。 体验的过程就不多说了，整体感觉还是非常专业的，这对于我这样没有过心理咨询体验的人来说，感受非常的好。倾诉和聆听的过程中，我没有感受到任何的尴尬，反而有一种莫名的信任。我信任坐在对面的那个人是理解我的，这让我觉得难能可贵。（也许体验的好坏与咨询师有关，我遇到的这个咨询师本身就是医务工作者，经验比较丰富） 结论在一个小时的咨询过程中，我们就问题的核心和解决方案进行了讨论。 我做了小小的笔记： 我的问题核心是“理解”。这包括父母对我的理解和我对父母的理解。这种理解是相互的，如果有一方不能很好的理解对方，矛盾就会显现。 我的负面情绪的来源是“控制”。同样地，控制也是相互的。而我这次咨询的最大收获之一便是，我理解了原来反控制的本质也是一种控制。多年来我一直处于对父母的控制的反抗中，在这过程中我痛苦的原因原来不是父母对我的控制欲，而是我不仅想要拜托父母的控制，更想要他们理解我。而他们由于种种原因，其实不太可能完全理解我，是我对他们的要求太高。我进入了一个反控制的死胡同里，要他们完全理解我并不是我的本意。这种错误的需求是让我痛苦的原因。 找到问题以后，便是解决的办法： 既然痛苦的原因是我的控制欲，那么想办法减少这种欲望就可以。又因为我本不想这么控制父母，这个问题就很简单了。 由于目前已经发生了很多矛盾，仍然需要减少后续矛盾发生的可能性。方案有二，减少接触的机会和减少对父母的需求。 如果发生了矛盾，排解的方式推荐对抗性的运动（如拳击）和找人分担。 总之，我的问题好像得到了解决。但这也还是看我自己，如果懂得了做人的道理却仍然学不会好好做人，这不就会显得很愚蠢吗？","link":"/zh-cn/my-first-psychological-counseling/"},{"title":"标记一封信 - MDN html 作业","text":"前言本文将会解析来自MDN web docs的一份html作业，内容较为基础，有一定html知识的同学可以选择绕道。 作业描述作业地址：标记一封信 将上述页面提供的一封信进行合适的html标记，使其成为一封传统的信件的格式。 答案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"author\" content=\"Dr Eleanor Gaye\"&gt; &lt;title&gt;my test letter&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles/letter.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"sender-column\"&gt; &lt;i&gt; &lt;b&gt;Dr. Eleanor Gaye&lt;/b&gt;&lt;br&gt; Awesome Science faculty&lt;br&gt; University of Awesome&lt;br&gt; Bobtown, CA 99999,&lt;br&gt; USA&lt;br&gt; &lt;b&gt;Tel:&lt;/b&gt; 123-456-7890&lt;br&gt; &lt;b&gt;Email:&lt;/b&gt; no_reply&amp;#64;example.com &lt;/i&gt; &lt;/p&gt; &lt;p class=\"sender-column\"&gt; &lt;time datetime=\"2016-01-20\"&gt;20 January 2016&lt;/time&gt; &lt;/p&gt; &lt;p&gt; &lt;i&gt; &lt;b&gt;Miss Eileen Dover&lt;/b&gt; 4321 Cliff Top Edge&lt;br&gt; Dover, CT9 XXX&lt;br&gt; UK &lt;/i&gt; &lt;/p&gt; &lt;h1&gt;Re: Eileen Dover university application&lt;/h1&gt; &lt;p&gt;Dear Eileen,&lt;/p&gt; &lt;p&gt;Thank you for your recent application to join us at the University of Awesome's science faculty to study as part of your &lt;abbr title=\"Philosophiae Doctor\"&gt;PhD&lt;/abbr&gt; next year. I will answer your questions one by one, in the following sections.&lt;/p&gt; &lt;h2&gt;Starting dates&lt;/h2&gt; &lt;p&gt;We are happy to accomodate you starting your study with us at any time, however it would suit us better if you could start at the beginning of a semester; the start dates for each one are as follows:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;First semester: &lt;time datetime=\"2016-09-09\"&gt;9 September 2016&lt;/time&gt;&lt;/li&gt; &lt;li&gt;Second semester: &lt;time datetime=\"2017-01-15\"&gt;15 January 2017&lt;/time&gt;&lt;/li&gt; &lt;li&gt;Third semester: &lt;time datetime=\"2017-05-02\"&gt;2 May 2017&lt;/time&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Please let me know if this is ok, and if so which start date you would prefer.&lt;/p&gt; &lt;p&gt;You can find more information about &lt;a target=\"_blank\" href=\"http://example.com\"&gt;important university dates&lt;/a&gt; on our website.&lt;/p&gt; &lt;h2&gt;Subjects of study&lt;/h2&gt; &lt;p&gt;At the Awesome Science Faculty, we have a pretty open-minded research facility — as long as the subjects fall somewhere in the realm of science and technology. You seem like an intelligent, dedicated researcher, and just the kind of person we'd like to have on our team. Saying that, of the ideas you submitted we were most intrigued by are as follows, in order of priority:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;Turning H&lt;sub&gt;2&lt;/sub&gt;O into wine, and the health benefits of Resveratrol (C&lt;sub&gt;14&lt;/sub&gt;H&lt;sub&gt;12&lt;/sub&gt;O&lt;sub&gt;3&lt;/sub&gt;.)&lt;/li&gt; &lt;li&gt;Measuring the effect on performance of funk bassplayers at temperatures exceeding 30&amp;deg;C (86&amp;deg;F), when the audience size exponentially increases (effect of 3 &amp;#215; 10&lt;sup&gt;3&lt;/sup&gt; &amp;gt; 3 &amp;#215; 10&lt;sup&gt;4&lt;/sup&gt;.)&lt;/li&gt; &lt;li&gt;&lt;abbr title=\"Hypertext Markup Language\"&gt;HTML&lt;/abbr&gt; and &lt;abbr title=\"Cascading Style Sheets\"&gt;CSS&lt;/abbr&gt; constructs for representing musical scores.&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;So please can you provide more information on each of these subjects, including how long you'd expect the research to take, required staff and other resources, and anything else you think we'd need to know? Thanks.&lt;/p&gt; &lt;h2&gt;Exotic dance moves&lt;/h2&gt; &lt;p&gt;Yes, you are right! As part of my post-doctorate work, I &lt;em&gt;did&lt;/em&gt; study exotic tribal dances. To answer your question, my favourite dances are as follows, with definitions:&lt;/p&gt; &lt;dl&gt; &lt;dt&gt;Polynesian chicken dance&lt;/dt&gt; &lt;dd&gt;A little known but very influential dance dating back as far as 300&lt;abbr title=\"Before Christ\"&gt;BC&lt;/abbr&gt;, a whole village would dance around in a circle like chickens, to encourage their livestock or be \"fruitful\".&lt;/dd&gt; &lt;dt&gt;Icelandic brownian shuffle&lt;/dt&gt; &lt;dd&gt;Before the Icelanders developed fire as a means of getting warm, they used to practice this dance, which involved huddling close together in a circle on the floor, and shuffling their bodies around in imperceptably tiny, very rapid movements. One of my fellow students used to say that he thought this dance inspired modern styles such as Twerking.&lt;/dd&gt; &lt;dt&gt;Arctic robot dance&lt;/dt&gt; &lt;dd&gt;An interesting example of historic misinformation, English explorers in the 1960s believed to have discovered a new dance style characterised by \"robotic\", stilted movements, being practiced by inhabitants of Northern Alaska and Canada. Later on however it was discovered that they were just moving like this because they were really cold.&lt;/dd&gt; &lt;/dl&gt; &lt;p&gt;For more of my research, see my &lt;a target=\"_blank\" href=\"http://example.com\"&gt;exotic dance research page&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Yours sincerely,&lt;/p&gt; &lt;pre&gt; &lt;/pre&gt; &lt;p&gt;Dr Eleanor Gaye&lt;/p&gt; &lt;p&gt;University of Awesome motto: &lt;q cite=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q\"&gt;Be awesome to each other.&lt;/q&gt; -- &lt;cite title=\"http://example.com\"&gt;Bill S Preston, &lt;abbr title=\"Esquire\"&gt;Esq&lt;/abbr&gt;&lt;/cite&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 页面构建创建DOCTYPE声明，用以表明文本格式。 创建html、head、body基础标签。 设置文本语言和字符集，在html的属性中和head标签的meta中。 引入css文件，在head中使用link标签。 设置文档title和必要的meta信息（作者）。 使用标题和段落标签进行排版。 样式调整为发信人段落添加样式引用（class），并对其使用适当的斜体、加粗样式。 使用列表来标记信中列举出来的信息，用ol表示有序列表，用ul表示无序列表，用dl表示描述列表。 使用超链接标记站点信息，并设置合适的title和target属性。 对文中的化学式、温度、公式使用合适的上下标，这里也可以对一些特殊字符使用url转义来在页面上展示，如&amp;deg;表示&deg;。 使用pre标签保留文本中的换行。 语义标记使用时间标签标记文档中的时间。 使用缩写标签对文档中的缩写进行解释。 使用强调标签对文中的某些短语做标记。 使用引用标签标示文中的引文和出处，q和blockquote标签需要设置cite属性以表示出处（不显示），并且需要使用cite标签来显示出处。","link":"/zh-cn/marking-up-a-letter/"},{"title":"浅谈开源许可证","text":"前言前段时间Github上面华为开源的项目被指违反开源许可证的事情闹得不小，事件传送门。从这个事情可以看出，很大一部分国内的开发人员对于开源的概念还是处于懵懂的状态，对于开源与版权的关系还是搞不清楚。那么，对于开源的项目要如何维护自己的权益，如何遵守社区的规范呢？ 开源协议相信大家在写代码的时候都会先去Github上面找找有没有前人的经验可以借鉴，但是通常都会忽略的是，很多项目都有开源许可证。如果一不小心违反了开源许可证所规定的内容，就容易发生与上面的华为员工一样的情况，被原作者要求按照许可证修改你的项目，甚至可能面临被起诉的风险。 开源协议的意义开源协议的存在不仅仅是为了保护作者，更是为了保护使用者。开源协议的存在使作者拥有了自己项目的版权，别人如果需要使用该项目，那就必须要按照协议所规定的来操作。另外，如果有人用项目来做违法的事情，开源协议的存在让作者可以免责，责任全部由使用者来承担。 对于项目的使用者来说，开源协议的存在更是让使用的权限变得更清晰。对于一些宽松的协议来说，除了不能直接抄袭之外，其他的基本没有限制。在协议的保护下，使用者也不会再被作者冠以侵权的名义了。 开源协议的分类这里主要介绍三种较为常见的开源协议。 MIT：允许别人以任何方式使用。署名作者。原作者不承担代码使用后的风险。 APACHE：授权使用者免费使用个人专利。使用者必须放置协议说明。使用者需要对修改部分声明。禁止用作者的名号进行商业广告。原作者不承担代码使用后风险。 GPL：使用者须遵循相同的协议进行开源。原作者不承担代码使用后风险。 另外需要注意的是，在不同的平台上发布的项目，会默认遵守该平台的协议，例如Github上的项目，别人可以毫无限制地查看和fork你的项目。 如果需要了解更为详细的内容，请移步Choose an open source license。 知识共享协议与开源协议一样，知识共享协议是为了方便知识的传播和保护作者版权而生的。 可以到选择一个知识共享协议来为自己选择一个合适的知识共享协议。 这里推荐选择CC BY-NC-ND 4.0协议，它的规则是禁止商用，保持原文，明确署名。选择这个较为严苛的协议的原因是，防止别人将原文的排版打乱，影响读者阅读，其次，也方便读者发现错误时，可以及时联系原作者加以修正。 同样的，在任何平台上发布的内容都会自动遵循该平台的知识共享协议，有些平台上面发布的内容，该平台会自动拥有版权。","link":"/zh-cn/open-source-license/"},{"title":"Scrum实践","text":"相关概念Agile敏捷的概念与瀑布模型是相对的，敏捷是一种以人为核心，不断迭代的技术团队管理方式。 以人为核心瀑布模型是以文档驱动的，而敏捷模式强调人与人之间的交流。 迭代瀑布模型通常用来管理一个比较大、比较完整的产品的开发周期，而敏捷则倾向于将产品分割为多个可交付的小周期开发任务，不断地迭代开发周期，以使产品渐渐趋于完善。 ScrumScrum是一种敏捷的模型，它注重过程，适应需求的变化，针对功能的发布强调快速迭代。 Scrum角色介绍Product Owner产品的拥有者，负责确定产品需求，交付日期。周期结束时，产品将交付给Product Owner。 Scrum MasterScrum Master是整个模式中最重要的管理人员，他将主导整个Scrum流程，协调Scrum Member和Product Owner ，确保流程正确，阻止成员以非Scrum思想进行工作，制止官僚主义，使成员专注于Sprint内的任务，停止无意义的争辩，构建交叉知识树，补充全局文档，让所有成员对整个系统，包括开发和测试都有良好的理解，承担小部分开发和测试，专注于每一个成员的个人诉求。如何做好Scrum Master是一个非常值得在实践中探讨的问题。 Scrum Team团队成员包括开发与测试人员，一般情况下人数在3到10人之间。 Scrum流程实践Product BacklogSprint中所有的需求都来自于需求池，需求池的维护需要靠Product Owner和Scrum Master共同承担。 Sprint Backlog在Sprint开始前，需要从需求池中挑选出不同重要程度的Product Backlog来作为本次迭代的任务。 Refine MeetingRefine Meeting标志着一次迭代的开始，在会议中，Product Owner会介绍挑选出来的需求任务。而团队成员则会就需求细节方面向Product Owner提问并确认。 Plan Meeting在所有人都对挑选出来的需求了解以后，需要进行故事点（需求难易程度）的估算、需求的拆分、子任务的工时估算、以及任务的分配。 Daily Stand Meeting整个Sprint周期一般为2到4周。在每日工作的过程中，需要进行Daily Stand Meeting，站会一般在早晨，所有团队成员总结昨日的工作，计划今日的工作，并提出遇到的问题。每日站会非常重要，他是Scrum以人为核心的基础，理想状态下能够让所有团队成员都了解所有需求的完成情况。 Code ReviewCode Review需要所有团队中的开发人员参加，以能够更好地找出代码中隐藏的问题，和让所有成员都对代码有所了解。 Demo Meeting产品演示一般安排在Sprint的倒数第二天，以防Product Owner对产品质疑后需要对产品打补丁。 Release &amp; Launch产品的发布一般安排在Sprint的倒数第二天，部署上线一般安排在最后一天。 Review Meeting回顾会议标志着一个Sprint的结束。回顾会议由Scrum Master主持，需要确认产品文档的产出是否正常，每个成员消耗的工时与预估的工时的对比，以及Sprint的健康程度。 实践建议Scrum Master的任务是非常重要的，也是非常繁重的，一个优秀的Scrum Master会处理好产品与成员的关系，并推动整个团队健康地完成迭代 。建议Scrum Master由成熟的团队成员轮流承担以减轻领导者压力，并培养团队成员的责任感。建议Scrum Master任要兼任小部分开发或者测试工作，以了解团队工作内容，防止官僚主义的发生。 另外，Sprint过程中每日的持续化集成报告也是很有价值的材料，可以借此敦促团队成员完成所需任务，以及及时了解项目情况。","link":"/zh-cn/practice-scrum/"},{"title":"字符串匹配算法","text":"问题引入有一个长字符串string，现在需要在该字符串中查找到一个特定短字符串pattern，并返回其位置。 上述问题为经典的字符串查找问题，这类问题数据算法的基础问题，应当熟记解决方法。 Brute-Force算法最简单的方案就是分别对string和pattern的每个位置进行依次比较。这样就会产生两个循环体分别对string和pattern进行遍历，很容易得出时间复杂度为string长度的二次幂。 核心代码： 12345678910111213141516boolean match = false;int index = -1;for (int i = 0; i &lt; source.length(); i++) &#123; for (int j = 0; j &lt; pattern.length(); j++) &#123; if (source.charAt(i + j) != pattern.charAt(j)) &#123; break; &#125; if (j == pattern.length() - 1) &#123; match = true; index = i; &#125; &#125; if (match) &#123; break; &#125;&#125; KMP算法KMP算法是经典的字符串匹配的改进算法。该算法利用pattern的最大重复子串长度表来减少循环次数。 最大重复子串长度表，即next表的计算方式： 123456789101112131415161718192021222324252627/** * eg. A B C A B D * -1 0 0 0 1 2 * @param pattern pattern string * @return next table of pattern string */private int[] calculateNext(String pattern) &#123; int[] next = new int[pattern.length()]; int j = 0; for (int i = 0; i &lt; next.length; i++) &#123; if (i &lt; 2) &#123; next[i] = i - 1; continue; &#125; if (pattern.charAt(j) == pattern.charAt(i - 1)) &#123; next[i] = j + 1; j++; &#125; else &#123; j = 0; next[i] = j; &#125; &#125; return next;&#125; 只看代码可能难于理解，我们来看next表的计算意义。 pattern的子串 前缀 后缀 最大重复子串长度 A 无 无 0 AB A B 0 ABC A，AB C，BC 0 ABCA A，AB，ABC A，CA，BCA 1 ABCAB A，AB，ABC，ABCA B，AB，CAB，BCAB 2 ABCABD A，AB，ABC，ABCA，ABCAB D，BD，ABD，CABD，BCABD 0 很明显，next表来自于最大重复子串长度表整体后移一位，并在第一位补-1。到这里，也就清楚了，KMP算法就是利用pattern的重复部分来减少查找的循环次数。 通过next表来进行匹配的核心代码： 1234567891011121314151617181920int i = 0;int j = 0;while (i &lt; source.length() &amp;&amp; j &lt; pattern.length()) &#123; if (source.charAt(i) == pattern.charAt(j)) &#123; i++; j++; &#125; else &#123; j = next[j]; if (j &lt; 0) &#123; i++; j++; &#125; &#125;&#125;if (j == pattern.length()) &#123; return i - pattern.length();&#125; else &#123; return -1;&#125; 通过代码应该很容易就能看出来，循环次数只与string的长度有关，KMP算法的时间复杂度为string长度的一次幂。也就是说，next表的结果指导了在匹配时pattern的移位长度。如果pattern没有任何重复的子串，KMP算法也将会退化为Brute-Force算法。","link":"/zh-cn/string-search/"},{"title":"本博客升级过程","text":"前言本文主要描述Hexo相关组件的升级方式和Next主题的升级方式。 Hexo升级本以为会比较复杂，其实非常简单，一条命令就能搞定。 1npm update 这里解释一下这个命令的含义。npm是javascript的管理依赖的工具，会随着node.js一起安装。通过npm工具可以安装、更新、删除依赖，上面列出的命令即可以更新当前项目下的所有依赖。另外所有的依赖版本信息都会存储在项目的package.json中，可以直接到该文件中去查看依赖的版本是否是最新的。 Next升级Next的升级就没有Hexo那么简单了。为了安全起见，需要将新的Next仓库clone到本地的另外一个目录，一般直接新建一个名为next-reloaded的目录用来存放新版本的文件。然后将新版本的Next直接clone到该目录，并将项目的主题设置为Next-reloaded。 剩余步骤： 手动Merge _config.xml（需要注意，启用新版本特性时可能需要安装新的依赖） 迁移静态资源： next/source/css/_custom/、 next/source/css/_variables/*、 next/layout/_custom/ 迁移其他自定义资源：404页面、头像图片等 检查language配置​ 利用hexo server命令进行本地调试，检查页面console中的报错，以及页面元素是否显示正常​ 参考资料How to update hexo?从 NexT v5.1.x 更新","link":"/zh-cn/upgrade-hexo-and-next/"},{"title":"结构化一个页面的内容 - MDN html 作业","text":"前言本文将会解析来自MDN web docs的一份html作业，内容较为基础，有一定html知识的同学可以选择绕道。 作业描述作业地址：结构化一个页面的内容 将上述页面提供的html文件加上结构化标签，使应用于结构化标签的css生效。 答案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Birdwatching&lt;/title&gt; &lt;link href=\"https://fonts.googleapis.com/css?family=Roboto+Condensed:300|Cinzel+Decorative:700\" rel=\"stylesheet\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles/index.css\"&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"//html5shiv.googlecode.com/svn/trunk/html5.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;h1&gt;Birdwatching&lt;/h1&gt; &lt;img src=\"images/dove.png\" alt=\"a simple dove logo\"&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;Home&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Get started&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Photos&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Gear&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Forum&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;main&gt; &lt;article&gt; &lt;h2&gt;Welcome&lt;/h2&gt; &lt;p&gt;Welcome to our fake birdwatching site. If this were a real site, it would be the ideal place to come to learn more about birdwatching, whether you are a beginner looking to learn how to get into birding, or an expert wanting to share ideas, tips, and photos with other like-minded people.&lt;/p&gt; &lt;p&gt;So don't waste time! Get what you need, then turn off that computer and get out into the great outdoors!&lt;/p&gt; &lt;/article&gt; &lt;aside&gt; &lt;h2&gt;Favourite photos&lt;/h2&gt; &lt;a href=\"images/favorite-1.jpg\"&gt;&lt;img src=\"images/favorite-1_th.jpg\" alt=\"Small black bird, black claws, long black slender beak, links to larger version of the image\"&gt;&lt;/a&gt; &lt;a href=\"images/favorite-2.jpg\"&gt;&lt;img src=\"images/favorite-2_th.jpg\" alt=\"Top half of a pretty bird with bright blue plumage on neck, light colored beak, blue headdress, links to larger version of the image\"&gt;&lt;/a&gt; &lt;a href=\"images/favorite-3.jpg\"&gt;&lt;img src=\"images/favorite-3_th.jpg\" alt=\"Top half of a large bird with white plumage, very long curved narrow light colored break, links to larger version of the image\"&gt;&lt;/a&gt; &lt;a href=\"images/favorite-4.jpg\"&gt;&lt;img src=\"images/favorite-4_th.jpg\" alt=\"Large bird, mostly white plumage with black plumage on back and rear, long straight white beak, links to larger version of the image\"&gt;&lt;/a&gt; &lt;/aside&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;This fake website example is CC0 — any part of this code may be reused in any way you wish. Original example written by Chris Mills, 2016.&lt;/p&gt; &lt;p&gt;&lt;a href=\"http://game-icons.net/lorc/originals/dove.html\"&gt;Dove icon&lt;/a&gt; by Lorc.&lt;/p&gt; &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 使用到的结构化标签有： header：页眉 nav：导航栏 main：主要内容 article：文章 aside：侧边栏 footer：页脚 这里需要注意，仅仅设置这些html标签是不会对页面的布局产生任何影响的，这些标签只是作为页面结构的标识，以便后续使用css等手段对页面进行排版调整所用。","link":"/zh-cn/structuring-a-page-of-content/"},{"title":"Java 中的双重检查锁(Double-Checked Locking)的问题","text":"Java 中的双重检查锁不知道从什么时候开始，双重锁检机制开始在 Java 程序员中流传开来，并被一些不成熟的程序员所称道。然而，双重锁检机制无论在 Java 的什么年代，都是一个不折不扣的代码陷阱。 12345678910111213// double-checked-locking - don't do this!private static Something instance = null;public Something getInstance() &#123; if (instance == null) &#123; synchronized (this) &#123; if (instance == null) instance = new Something(); &#125; &#125; return instance;&#125; 这段代码粗看上去使用了很“神奇”的 Java 多线程技巧，“巧妙”利用重复地两次检查对象是否为空来避免了大部分情况下 synchronized 关键字的性能消耗。 双重锁检的一种优化方案有很多人对上述代码提出了异议，他们认为，对象的初始化和对象的赋值操作之间可能存在重排序，有一定的可能性 getInstance 方法返回的对象不是完全初始化完成的，因此解决方案是需要为 instance 变量添加 volatile 修饰。看上去这就是完美的解决方案了，volatile 关键字在对象的初始化和对象的赋值操作之间添加了 Happen-before 关系，因此也就不存在重排序的问题了。 然而，首先，volatile 关键字在 Java 1.5 以前不能保证线程获取到的对象是最新的。其次，对象的初始化和对象的赋值操作之间的 Happen-before 关系是在 JMM 被重新修订之后（JSR-133）才出现的。也就是说，在 Java 1.5 以前，添加 volatile 与否对这段代码来说都是一样的效果，volatile 并不能解决任何问题。在 Java 1.5 以后，添加 volatile 与否对这段代码来说也都是一样的效果，因为新的 JMM 已经可以保证对象的初始化和对象的赋值操作之间存在 Happen-before 关系。 扩展阅读：Is volatile expensive? synchronized 性能很差？最重要的问题是，为什么用这种方式去写代码？大部分人都会说，因为 synchronized 关键字的性能很差，所以需要用一些技巧来避免大量使用它。那么 synchronized 关键字的性能真的很差吗？ 早在 2001 年就有 IBM 的研究员做了相关的调查。 由于同步机制涉及缓存的刷新和失效,Java 中的同步块通常比其他关键机制更为消耗性能,其他机制通常只用“检查并赋值”的机器级别的原子指令来执行。并且，就算只在单核上运行单线程的代码，同步块仍然比非同步的代码要慢。而如果同步需要对锁进行竞争,那么性能就会大大下降。 幸运的是,JVM 的持续改进既改进了整个 Java 程序的性能,也降低了每个版本使用同步的相对成本。此外,同步的性能成本往往被夸大了。众所周知，一个同步的方法调用比不同步的方法调用慢50倍。虽然该声明可能是正确的,但它也具有误导性,并导致许多开发人员在需要的情况下仍想要避免同步。 在这篇文章里你能找到对于 synchronized 关键字的一份简单的性能报告，这也许能帮助你理解，synchronized 关键字的性能在大部分情况下并不如你想象中的消耗那么大。并且，不同版本间的比较可以看出，JDK 的持续优化对于同步块的性能提升有多大。 不要再使用双重锁检了既然双重锁检是错误的写法，并且 synchronized 关键字的性能消耗也不大，那么如果能避免 synchronized 关键字的话，最优的写法是什么呢？ 仍然以单例为例： 1234567private static class LazySomethingHolder &#123; public static Something something = new Something();&#125;public static Something getInstance() &#123; return LazySomethingHolder.something;&#125; 这样编写单例的好处有： 避免了 synchronized 关键字的性能消耗 在加载 LazySomethingHolder 类的时候才会初始化单例，懒加载 代码简洁明了 如果深究的话你会注意到，能够保证对象初始化和赋值之间存在 Happen-before 关系是由于 static 关键字的原因。在最新的 JLS 中有具体说明 JVM 是如何处理这里的逻辑的：JLS 12.4.2。 参考资料 JSR 133 FAQ Fixing the Java Memory Model, Part 2 what is the correct way to guarantee a non-final reference field will never be read as null?","link":"/zh-cn/talk-about-double-locking-problem/"},{"title":"【译】Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分","text":"原文地址：Distributed transactions in Spring, with and without XA - Part I 原文作者：David Syer 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-1.md 译者：JackEggie 校对者：fireairforce Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分 Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分 Spring 的分布式事务实现 — 使用和不使用 XA — 第二部分 Spring 的分布式事务实现 — 使用和不使用 XA — 第三部分 Spring 的 7 种事务处理模式 虽然在 Spring 中分布式事务通常使用 Java Transaction API 和 XA 协议实现，但也有其他的实现方式。最好的实现方式取决于应用程序所使用资源的类型，以及你是否愿意在性能、安全性、可靠性和数据完整性之间做出权衡。针对这个 Java 中的典型问题，Spring 的开发者 David Syer 将会介绍 7 种 Spring 分布式应用的实现方式，其中 3 种实现使用了 XA 协议，另外 4 种使用了其他的实现方式。（中级知识点） Spring 框架对 Java Transaction API (JTA) 的支持使应用程序能够无需在 Java EE 容器中即可使用分布式事务和 XA 协议。然而，即使有了这种支持，XA 的性能开销仍然很大，而且可能不可靠并且难于管理。不过令人惊喜的是，某种特定类型的应用程序可以完全避免使用 XA 来实现分布式事务。 为了让你对分布式事务的各种实现方式有充分的理解和思考，我将详细分析这 7 种事务处理模式，并提供代码示例帮助你理解得更具体。我将根据安全性和可靠性来依次介绍这些模式，从通常来说数据完整性和原子性程度最高的模式开始。当你按顺序浏览时，你会看到越来越多的警示说明和限制条件。这些模式的性能开销也大致相反（从开销最大的模式开始）。与编写业务代码完全不同的是，这些模式都是从架构复杂度和技术难度考虑的，所以我不会关心业务用例，只关心使每种模式正常工作的最小代码量。 注意，只有前三种模式涉及 XA。而从性能的角度考虑，这些模式可能无法使用或性能差到不可接受。我不会像介绍其他模式那样对 XA 模式有详细的讨论，因为 XA 在其他地方已经有很多介绍了，不过我提供了第一个模式（基于 XA）的简单示例。通过阅读本文，你将了解使用分布式事务可以做什么、不能做什么，何时使用 XA、何时不使用 XA，以及如何避免使用 XA。 分布式事务及其原子性一个分布式事务通常包含多个事务资源。事务资源是指关系型数据库和消息中间件的连接。一个典型的事务资源都会有像 begin()、rollback()、commit() 这样的 API。在 Java 中，一个事务资源通常表现为底层连接工厂提供的实例：对于数据库来说，就是 Connection 对象（由 DataSource 提供）或是 Java Persistence API（JPA）的 EntityManager 对象；对于 Java Message Service（JMS）来说，则是 Session 对象。 在一个典型的例子中，一个 JMS 消息触发了数据库的更新。根据时间先后顺序，一次成功的交互过程如下： 启动消息事务 接收消息 启动数据库事务 更新数据库 提交数据库事务 提交消息事务 如果数据库在更新数据时报错（如约束冲突），理想的交互顺序如下： 启动消息事务 接收消息 启动数据库事务 更新数据库失败！ 回滚数据库事务 回滚消息事务 在这个例子中，消息在最后回滚完成之后回到了中间件，在某个时刻将再次提交到另一个事务中。这通常是一件好事，因为如果这样做的话更新数据时发生的错误将会被记录下来。（自动重试和异常处理的机制超出了本文的讨论范围。） 上述两个例子中最重要的特点就是原子性，逻辑上来说，一个事务要么完全成功，要么完全失败。 那么是什么保证了上面两个例子在流程上的一致性呢？我们必须在事务资源之间进行一些同步，以便在一个事务提交之后，另一个事务才能提交。否则，整个事务就不是原子性的。因为涉及多个资源，所以事务是分布式的。如果不进行同步，事务就不会是原子性的。分布式事务的理论和实现上的困难都与资源的同步（或缺少资源）有关。 下面讨论的前三个模式都是基于 XA 协议的。由于这些模式已经被普及，所以在这里我不会介绍得很详细。如果你对 XA 的模式非常熟悉，你可以直接跳到共享事务资源模式。 完整的 XA 协议与两阶段提交（2PC）如果你需要确保应用程序的事务在服务器宕机（服务器崩溃或断电）之后仍能够恢复，那么完整的 XA 协议是你唯一的选择。在下面的例子中，用于同步事务的共享资源是一个特殊的事务管理器，它使用 XA 协议协调了进程的信息。在 Java 中，从开发者的角度来看，该协议是通过 JTA 的 UserTransaction 对象暴露出来的。 作为一个系统接口，XA 是大多数开发者从未见过的一种底层技术。开发者需要知道 XA 协议的存在、它能做什么、性能消耗如何，以及它是如何操作事务资源的。性能消耗来自于两阶段提交（2PC）协议，事务管理器使用该协议来确保所有资源能在事务结束前就事务的结果达成一致。 如果应用程序是基于 Spring 构建的，它将使用 Spring 中的 JtaTransactionManager 和 Spring 声明性事务管理来隐藏底层同步的细节。对于开发者来说，使用 XA 与否取决于工厂资源的配置方式：在应用程序中如何配置 DataSource 实例和事务管理器。本文包含了一个示例应用程序（atomikos-db 项目），它演示了这种配置方式。该应用程序中只有 DataSource 实例和事务管理器是基于 XA 或者 JTA 的。 要查看示例的运行方式，请运行 com.springsource.open.db 下的单元测试。MulipleDataSourceTests 类向两个数据源插入了数据，然后使用 Spring 的集成支持特性将事务回滚，如清单 1 所示： 清单 1. 事务回滚123456789101112131415161718@Transactional @Test public void testInsertIntoTwoDataSources() throws Exception &#123; int count = getJdbcTemplate().update( \"INSERT into T_FOOS (id,name,foo_date) values (?,?,null)\", 0, \"foo\"); assertEquals(1, count); count = getOtherJdbcTemplate() .update( \"INSERT into T_AUDITS (id,operation,name,audit_date) values (?,?,?,?)\", 0, \"INSERT\", \"foo\", new Date()); assertEquals(1, count); // 数据的变更将在此方法退出后回滚 &#125; 然后 MulipleDataSourceTests 将会验证这两个操作都回滚完成，如清单 2 所示： 清单 2. 验证回滚123456789101112@AfterTransaction public void checkPostConditions() &#123; int count = getJdbcTemplate().queryForInt(\"select count(*) from T_FOOS\"); // 该数据变更已被测试框架回滚 assertEquals(0, count); count = getOtherJdbcTemplate().queryForInt(\"select count(*) from T_AUDITS\"); // 由于 XA 的存在，该数据变更也被回滚了 assertEquals(0, count); &#125; 为了更好地理解 Spring 事务管理的工作原理以及配置的方式，请参阅 Spring 参考文档。 XA 与 1PC 优化这种模式通过避免 2PC 的性能开销对许多只包含单资源事务的事务管理器进行了优化。你将会希望你的应用程序服务能够借此解决这个问题。 XA 与最终资源策略XA 事务管理器的另一个特性是，当除某一个资源外的所有资源都支持 XA 时，它仍然可以提供与所有资源都支持 XA 时相同的数据恢复保证。通过对资源进行排序，并使非 XA 资源参与决策来实现该特性。如果提交失败，则回滚所有其他资源。这几乎是 100% 的完全性保证，但还不够完美。当提交失败时，除非采取额外的措施（在一些高端实现中有这样的实现），否则报错的跟踪信息会很少。 共享事务资源模式在某些系统中，为了降低复杂性和增加吞吐量，一种较好的模式是通过确保系统中的所有事务资源实际上都是同一个资源的不同形式，从而完全消除对 XA 的依赖。显然，这在所有的用例中都是不可能的，但这种模式与 XA 一样可靠，而且通常要快得多。这样的共享事务资源模式是足够可靠的，但只限于某些特定的平台和处理场景。 有一个这种模式的简单例子对很多人来说都很熟悉，即在对象关系映射（ORM）组件和 JDBC 组件之间共享数据库的 Connection。这就是你使用支持 ORM 工具的 Spring 事务管理器时所发生的事情，如 Hibernate、EclipseLink 和 Java Persistence API（JPA）。同一个事务可以安全地跨 ORM 和 JDBC 组件使用，该执行过程通常由控制事务的服务级方法来实现。 该模式的另一个有效用法是单个数据库的消息驱动更新（如本文中介绍的简单例子所示）。消息中间件系统需要将数据存储在某个地方，通常是关系数据库中。要实现此模式，只需指定消息传递系统的目标数据库为同一个业务数据库即可。此模式需要消息中间件的供应商公开其存储策略的详细信息，以便可以将其配置指向相同的数据库并挂接到相同的事务中。 并不是所有的供应商都能做到这一点。另一种适用于几乎所有数据库的方式，是使用 Apache ActiveMQ 进行消息传递并将存储策略配置到消息代理服务器中。了解其中的技巧，配置起来就会非常简单。本文的 shared-jms-db 示例项目展示了这种配置方式。应用程序的代码中（在本例中是单元测试）不需要感知这种模式的使用，因为它已经在 Spring 配置中已经以声明方式被启用了。 示例中名为 SynchronousMessageTriggerAndRollbackTests 的单元测试验证了所有同步消息的接收处理。testReceiveMessageUpdateDatabase 方法接收了两条消息，并将这两条消息中的数据记录插入到数据库中。当退出该方法时，测试框架将会回滚当前的事务，接下来你就可以验证消息和数据库更新都已经回滚，如清单 3 所示： 清单 3. 验证消息和数据库更新的回滚12345678@AfterTransactionpublic void checkPostConditions() &#123; assertEquals(0, SimpleJdbcTestUtils.countRowsInTable(jdbcTemplate, \"T_FOOS\")); List&lt;String&gt; list = getMessages(); assertEquals(2, list.size());&#125; 该配置最重要的特性是 ActiveMQ 的持久化策略，它将业务数据源的消息系统连接到同一个 DataSource，用于接收消息的 Spring JmsTemplate 上的标志位也同样重要。配置 ActiveMQ 持久化策略的方式如清单 4 所示： 清单 4. ActiveMQ 的持久化配置1234567891011121314151617181920&lt;bean id=\"connectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\" depends-on=\"brokerService\"&gt; &lt;property vm://localhost?async=false\" /&gt;&lt;/bean&gt;&lt;bean id=\"brokerService\" class=\"org.apache.activemq.broker.BrokerService\" init-method=\"start\" destroy-method=\"stop\"&gt; ... &lt;property &gt; &lt;bean class=\"org.apache.activemq.store.jdbc.JDBCPersistenceAdapter\"&gt; &lt;property &gt; &lt;bean class=\"com.springsource.open.jms.JmsTransactionAwareDataSourceProxy\"&gt; &lt;property /&gt; &lt;property /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property /&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 用于接收消息的 Spring JmsTemplate 上的标志位配置如清单 5 所示： 清单 5. 为事务配置 JmsTemplate12345&lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; ... &lt;!-- 这很重要... --&gt; &lt;property /&gt;&lt;/bean&gt; 如果没有设置 sessionTransacted=true，就永远不会执行 JMS 会话事务的 API 调用，并且消息的接收将无法回滚。这里重要的一点是嵌入式消息代理服务器中的特殊参数 async=false 和对 DataSource 的包装，他们共同确保了 ActiveMQ 和 Spring 共同使用了同一个 JDBC 事务的 Connection。 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。","link":"/zh-cn/distributed-transactions-in-spring-with-and-without-xa-part-1/"},{"title":"【译】如何用 Python 从零开始构建你自己的神经网络","text":"原文地址：How to build your own Neural Network from scratch in Python 原文作者：James Loy 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/how-to-build-your-own-neural-network-from-scratch-in-python.md 译者：JackEggie 校对者：lsvih, xionglong58 如何用 Python 从零开始构建你自己的神经网络 一个帮助初学者理解深度神经网络内部工作机制的指南 写作动机： 为了使我自己可以更好地理解深度学习，我决定在没有像 TensorFlow 这样的深度学习库的情况下，从零开始构建一个神经网络。我相信，理解神经网络的内部工作原理对任何有追求的数据科学家来说都很重要。 这篇文章包含了我所学到的东西，希望对你们也有用。 什么是神经网络？大多数介绍神经网络的文章在描述它们时都会与大脑做类比。在不深入研究与大脑类似之处的情况下，我发现将神经网络简单地描述为给定输入映射到期望输出的数学函数更容易理解一些。 神经网络由以下几个部分组成： 一个输入层，x 任意数量的隐含层 一个输出层，ŷ 层与层之间的一组权重和偏差，W 和 b 每个隐含层中所包含的一个可选的激活函数，σ。在本教程中，我们将使用 Sigmoid 激活函数。 下图展示了 2 层神经网络的架构（注：在计算神经网络中的层数时，输入层通常被排除在外） 2 层神经网络的架构 在 Python 中创建一个神经网络的类很简单。 1234567class NeuralNetwork: def __init__(self, x, y): self.input = x self.weights1 = np.random.rand(self.input.shape[1],4) self.weights2 = np.random.rand(4,1) self.y = y self.output = np.zeros(y.shape) 训练神经网络 一个简单的 2 层神经网络的输出 ŷ 如下： 你可能注意到了，在上面的等式中，只有权重 W 和偏差 b 这两个变量会对输出 ŷ 产生影响。 当然，合理的权重和偏差会决定预测的准确程度。将针对输入数据的权重和偏差进行微调的过程就是训练神经网络的过程。 训练过程的每次迭代包括以下步骤： 计算预测输出的值 ŷ，即前馈 更新权重和偏差，即反向传播 下面的序列图展示了这个过程。 前馈过程正如我们在上面的序列图中看到的，前馈只是一个简单的计算过程，对于一个基本的 2 层神经网络，它的输出是： 让我们在 Python 代码中添加一个前馈函数来实现这一点。注意，为了简单起见，我们假设偏差为 0。 1234567891011class NeuralNetwork: def __init__(self, x, y): self.input = x self.weights1 = np.random.rand(self.input.shape[1],4) self.weights2 = np.random.rand(4,1) self.y = y self.output = np.zeros(self.y.shape) def feedforward(self): self.layer1 = sigmoid(np.dot(self.input, self.weights1)) self.output = sigmoid(np.dot(self.layer1, self.weights2)) 但是，我们仍然需要一种方法来评估预测的“精准程度”（即我们的预测有多好）？而损失函数能让我们做到这一点。 损失函数可用的损失函数有很多，而我们对损失函数的选择应该由问题本身的性质决定。在本教程中，我们将使用简单的平方和误差作为我们的损失函数。 这就是说，平方和误差只是每个预测值与实际值之差的总和。我们将差值平方后再计算，以便我们评估误差的绝对值。 训练的目标是找到能使损失函数最小化的一组最优的权值和偏差。 反向传播过程现在我们已经得出了预测的误差（损失），我们还需要找到一种方法将误差传播回来，并更新我们的权重和偏差。 为了得出调整权重和偏差的合适的量，我们需要计算损失函数对于权重和偏差的导数。 回忆一下微积分的知识，计算函数的导数就是计算函数的斜率。 梯度下降算法 如果我们已经算出了导数，我们就可以简单地通过增大/减小导数来更新权重和偏差（参见上图）。这就是所谓的梯度下降。 然而，我们无法直接计算损失函数对于权重和偏差的导数，因为损失函数的等式中不包含权重和偏差。 因此，我们需要链式法则来帮助我们进行计算。 为了更新权重使用链式法则求解函数的导数。注意，为了简单起见，我们只展示了假设为 1 层的神经网络的偏导数。 哦！这真难看，但它让我们得到了我们需要的东西 —— 损失函数对于权重的导数（斜率），这样我们就可以相应地调整权重。 现在我们知道要怎么做了，让我们向 Pyhton 代码中添加反向传播函数。 1234567891011121314151617181920class NeuralNetwork: def __init__(self, x, y): self.input = x self.weights1 = np.random.rand(self.input.shape[1],4) self.weights2 = np.random.rand(4,1) self.y = y self.output = np.zeros(self.y.shape) def feedforward(self): self.layer1 = sigmoid(np.dot(self.input, self.weights1)) self.output = sigmoid(np.dot(self.layer1, self.weights2)) def backprop(self): # 应用链式法则求出损失函数对于 weights2 和 weights1 的导数 d_weights2 = np.dot(self.layer1.T, (2*(self.y - self.output) * sigmoid_derivative(self.output))) d_weights1 = np.dot(self.input.T, (np.dot(2*(self.y - self.output) * sigmoid_derivative(self.output), self.weights2.T) * sigmoid_derivative(self.layer1))) # 用损失函数的导数(斜率)更新权重 self.weights1 += d_weights1 self.weights2 += d_weights2 如果你需要更深入地理解微积分和链式法则在反向传播中的应用，我强烈推荐 3Blue1Brown 的教程。 观看视频教程 融会贯通现在我们已经有了前馈和反向传播的完整 Python 代码，让我们将神经网络应用到一个示例中，看看效果如何。 我们的神经网络应该通过学习得出一组理想的权重来表示这个函数。请注意，仅仅是求解权重的过程对我们来说也并不简单。 让我们对神经网络进行 1500 次训练迭代，看看会发生什么。观察下图中每次迭代的损失变化，我们可以清楚地看到损失单调递减至最小值。这与我们前面讨论的梯度下降算法是一致的。 让我们看一下经过 1500 次迭代后神经网络的最终预测（输出）。 1500 次训练迭代后的预测结果 我们成功了！我们的前馈和反向传播算法成功地训练了神经网络，预测结果收敛于真实值。 请注意，预测值和实际值之间会存在细微的偏差。我们需要这种偏差，因为它可以防止过拟合，并允许神经网络更好地推广至不可见数据中。 后续的学习任务幸运的是，我们的学习旅程还未结束。关于神经网络和深度学习，我们还有很多内容需要学习。例如： 除了 Sigmoid 函数，我们还可以使用哪些激活函数？ 在训练神经网络时使用学习率 使用卷积进行图像分类任务 我将会就这些主题编写更多内容，请在 Medium 上关注我并留意更新！ 结语当然，我也在从零开始编写我自己的神经网络的过程中学到了很多。 虽然像 TensorFlow 和 Keras 这样的深度学习库使得构建深度神经网络变得很简单，即使你不完全理解神经网络内部工作原理也没关系，但是我发现对于有追求的数据科学家来说，深入理解神经网络是很有好处的。 这个练习花费了我大量的时间，我希望它对你们也有帮助！ 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。","link":"/zh-cn/how-to-build-your-own-neural-network-from-scratch-in-python/"},{"title":"【译】我们从招聘技术经理的过程中学到了什么","text":"原文地址：What we’ve learned about hiring engineering managers 原文作者：Lena Reinhard 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/what-we-ve-learned-about-hiring-engineering-managers.md 译者：JackEggie 校对者：portandbridge, Baddyo 我们从招聘技术经理的过程中学到了什么 在过去的一年里，我们对于理解负责 CircleCI 的技术经理所需的优秀品质有了重要的转变，并从中了解到我们作为一个组织的需求和价值观。我们大幅改变了招聘流程，通过这些努力，我们聘用了一些出色的人才，使我们技术管理团队的人数翻了一番。现在，我们想和大家分享这些经验。 用与招聘工程师类似的方法招聘技术经理去年，我们分享了“我们是如何面试工程师的”。这是我们当时同时用在工程师和技术经理身上的流程。在整个 2018 年中，有数百名候选人通过了我们的技术招聘流程。我们的工程师招聘流程如下： 申请人简历审查 &gt; 招聘经理电话筛选 &gt; 编码风格评估 &gt; 整体能力评估 &gt; 最后一轮面试（考察团队协作、CTO 谈话、产品面试）。有关此流程的更多细节，请参见博客文章。 在 2018 年初，我们对工程师和技术经理采用了相同的招聘流程。当时，我们招聘技术经理时重点关注的是候选人的技术背景与团队的技术工作是否匹配。正如我们在之前的文章中所写的那样，“我们把一个编程问题加了进来，因为我们需要了解一项非常重要的东西 —— 候选人的价值观和优势是否与他们将要管理的团队保持一致。”我们对几个应聘技术经理的候选人采用了该招聘流程，发现大部分情况下都会到现场面试阶段，但在现场考察的过程中，我们发现他们的管理技能与我们所期望的不匹配 —— 而发现这一点的时候已经太晚了。 这让我们看到了一个更大的问题：它让我们意识到，我们试图统一招聘流程的做法，让我们把关注点和优化方向放在了错误的技能上。曾经有一段时间，我们认为技术经理精通技术是一件好事。我们当时打算采用 Spotify 模式，这能让不同部门的交付团队和经理通过某种规定来达成一致。随着我们在使用该组织模型的过程中对其的不断改进，也为了适应我们作为一个分散式技术组织的需求，我们意识到我们必须要更多地分散领导权。 我们引入了额外的角色来支持我们团队的不同职责：团队领导，负责其所在团队的交付；技术领导，负责推进技术工作。我们还将所有工程师对各级领导的期望编成新的技术能力模型。我们见证了这些改进的成效，这也鼓励我们继续深入理解一名好的技术经理需要哪些品质。 更好地支持工程师管理与技术大不相同。我们需要把技术管理工作与普通的管理工作区别开，它们需要不同的工作技能。CircleCI 的技术经理现在致力于人员的管理中：关注工程师、技术负责人、团队负责人的职业发展。他们会与其下属工程师们进行定期的一对一职业发展谈话，并负责他们的目标设定、反馈和职业生涯指导。他们还会跨团队交流，以保证团队的健康、知识共享、践行公司的价值观和各个团队间目标的一致性。这意味着我们工程师的经理对其下属的职业发展有着很大的兴趣和投入，团队中也会有专人指导他们完成产品交付过程。 使我们的流程适用于我们新的价值观在我们了解了技术管理中真正重要的能力之后，我们针对人员管理能力和能否践行公司的价值观调整了应聘职位。我们还改变了招聘流程和每个面试阶段的内容，以便在面试过程中及早确定应聘者在以上领域的能力。同时，我们为所有的应聘者调整了面试流程，现在的面试流程结构性更强、更注重面试时的行为了。 这是我们现在招聘技术经理的流程： 申请人简历审查 &gt; 招聘经理电话筛选 &gt; 面对面解题 &gt; 产品思维和工作拆分能力研讨 &gt; 最后一轮面试（技术团队成员面试、管理技能挖掘、产品面试）。 注：我们一直在寻找改进该流程的方式，所以这些阶段可能会变化 新的流程强调人员管理和践行公司的价值观，我们通过下面的步骤来评估这些能力： 招聘经理电话筛选： 该职位的招聘经理会和应聘者谈论他们在不同领域的管理经验。 考察团队协作： 这是一轮协作面试，应聘者会与我们的一名技术经理搭档。他们会一起想办法，解决我们团队以前所面临的两个难题，这两个问题仍然可能再次出现。就像我们的技术结对考察一样，我们希望面试能反映出我们正在做的工作 —— 作为一个技术管理团队，一起讨论问题和寻找解决方案在我们的日常工作中是非常重要的。这个阶段的面试帮助我们更多地了解应聘者会如何应对团队的问题，以及他们是如何与同事合作的。 产品思维和工作拆分能力评估： 在这一轮面试中，应聘者会和我们的技术管理团队的另一名成员讨论一些工作和交付的能力相关的问题，从客户价值的角度来讨论该问题。 技术团队成员面试： 应聘者会与他将要共事的一名高级工程师谈话。他们也会一起探讨团队在过去所面临的协作问题。我们希望应聘者的能力足以在了解自身局限性的情况下仍能指导、帮助并参与技术团队的工作讨论，也能在尽量避免直接做决策情况下支持技术团队作出自己的决策。 管理技能挖掘： 这一阶段的谈话通常是与技术管理团队的高级成员进行的，会深入讨论领导技能和应聘者的管理经验。 产品面试： 最后一轮面试是与一名产品团队的成员进行的，重点考察应聘者对产品、流程和构建健康的技术团队的看法。 下一阶段的计划以这种方式改变我们的流程有助于我们筛选应聘者的正确价值观和技能，并能及早确定哪些候选人符合这些价值观和技能。最后，它能使我们能够雇佣到优秀的管理者，他们关心整个团队，他们的价值观与团队的价值观相一致，他们能够帮助、带领我们的技术团队进入下一个成长阶段。 目前，我们正在努力使该流程与我们新采用的技术管理能力模型保持完全一致（该模型还没有公布，但是我们很快就会把它共享出来）。 如果你对我们的价值观和技术经理职位感兴趣，请联系我们 —— 欧洲技术经理和北美技术经理热招中！如果你希望与一个优秀的团队和一位对你的成长有帮助的经理共事感兴趣，欢迎以工程师的身份加入我们！ 欢迎评论我们的招聘流程，如果你对此有任何反馈，请发送 Email 至：lena@circleci.com 扩展阅读： 为什么我们要在 CircleCI 重新做职业规划 以局外人的身份进行面试：我最终如何在科技界崭露头角 加入分散式团队：主动提问 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。","link":"/zh-cn/what-we-ve-learned-about-hiring-engineering-managers/"},{"title":"【译】Go 语言概览","text":"原文地址：A bird’s eye view of Go 原文作者：Axel Wagner 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/birdseye-go.md 译者：JackEggie 校对者：40m41h42t, JalanJiang Go 语言概览本文摘要：本文非常笼统地总结了 Go 语言的定义、生态系统和实现方式，也尽力给出了与不同的需求所对应的参考文档，详情参见本文末尾。 每当我们说起“Go 语言”的时候，可能会因为场景的不同聊到很多完全不同的东西。因此，我尝试着对 Go 语言和其生态系统做一个概述，并在各部分内容中都列出相关的文档（这可能有点像是大杂烩，其中还包含了我最近实际遇到的许多问题）。让我们开始吧： Go 编程语言Go 语言是一种编程语言。作为一种权威，Go 语言规范中定义了代码的格式规范和代码所代表的含义。不符合该规范的都不是 Go 语言。同样地，该规范中没有提到的内容不视为该语言的一部分。目前由 Go 语言开发团队维护该规范，每半年发布一个新版本。在我写这篇文章的时候最新的版本是 1.12。 Go 语言规范规定了： 语法 变量的类型、值，及其语义 预先声明的标识符及其含义 Go 程序的运行方式 特殊的 unsafe 包（虽然没有包含所有的语义） 该规范应该已经足够让你实现一个 Go 语言的编译器了。实际上，已经有很多人基于此实现了许多不同的编译器。 Go 编译器及其运行时该语言规范只是一份文本文档，它本身不太有用。你需要的是实现了这些语义的软件，即编译器（分析、检查源代码，并将其转换为可执行的形式）和运行时（提供运行代码时所需的环境）。有很多这样的软件组合，他们都或多或少有些不同。示例如下： gc，Go 语言开发团队自己开发的纯 Go 语言实现的（有一小部分汇编实现）编译器和运行时。它随着 Go 语言一起发布。与其他此类工具不同的是，gc 并不严格区分编译器、组装器和链接器 —— 它们在实现的时候共享了大量的代码，并且会共享或传递一些重要职责。因此，通常无法链接由不同版本的 gc 所编译的包。 gccgo 和 libgo，gcc 的前端和其运行时。它是用 C 实现的，并且也由 Go 开发团队维护。然而，由于它是 gcc 组织的一部分，并根据 gcc 的发布周期发布，因此通常会稍微落后于 Go 语言规范的“最新”版本。 llgo，LLVM 的前端。我对其不太了解。 gopherjs，将 Go 代码编译为 JavaScript，并使用一个 JavaScript VM 和一些自定义代码作为运行时。长远来看，由于 gc 获得了 WebAssembly 的原生支持，它有可能会被淘汰。 tinygo，针对小规模编程的不完整实现。它可以通过自定义一个运行时运行在微控制器（裸机）或者 WebAssembly 虚拟机上。由于它的局限性，技术上来说它并没有实现 Go 语言的所有特性 —— 主要体现在它缺少垃圾回收器、并发和反射。 还有更多其他的实现，但这已经足以让你了解不同的实现方式。以上每一种方法都使用了不同的方式来实现 Go 语言，并具有自己与众不同的特性。他们可能存在的不同之处有（为了说明这一点，下面的某些说法可能会有点奇特）： int/uint 的大小 —— 长度可能为 32 位或 64 位。 运行时中基础功能的实现方式，如内存分配、垃圾回收和并发的实现。 遍历 map 的顺序并没有在 Go 语言中定义 —— gc 显然会将这类操作随机化，而 gopherjs 会用你使用的 JavaScript 实现遍历。 append 操作分配的所需额外内存空间大小 —— 但是，在分配额外空间时，不会再次分配更多的内存空间。 unsafe.Pointer 与 uintptr 之间的转换方式。特别指出，gc 对于该转换何时应该生效有自己的规则。通常情况下，unsafe 包是虚拟的，它会在编译器中被实现。 一般来说，根据规范中没有提到的某些细节（尤其是上面提到的那些细节）可以使你的程序用不同的编译器也能编译，但往往程序不会像你预期的那样正常工作。因此，你应该尽力避免此类事情发生。 如果你的 Go 语言是通过“正常”渠道安装的话（在官网上下载安装，或是通过软件包管理器安装），那么你会得到 Go 开发团队提供的 gc 和正式的运行时。在本文中，当我们在讨论“Go 是如何做的”时，若没有在上下文特别指明，我们通常就是在谈论 gc。因为它是最重要的一个实现。 标准库标准库是 Go 语言中附带的一组依赖包，它可以被用来立即构建许多实用的应用程序。它也由 Go 开发团队维护，并且会随着 Go 语言和编译器一起发布。一般来说，标准库的某种实现只能依赖与其共同发布的编译器才能正常使用。因为大部分（但不是所有）运行时都是标准库的一部分（主要包含在 runtime、reflect、syscall 包中）。由于编译器在编译时需要兼容当前使用的运行时，因此它们的版本要相同。标准库的 API 是稳定的，不会以不兼容的方式改变，所以基于某个指定版本的标准库编写的 Go 程序在编译器的未来版本中也可以正常运行。 有些标准库会完全自己实现整个库中的所有内容，而有些则只实现一部分 —— 开发者尤其会在 runtime、reflect、unsafe 和 syscall 包中实现自定义的功能。举个例子，我相信 AppEngine 标准库是出于安全考虑重新实现了标准库的部分功能的。这类重新实现的部分通常会尽量对用户保持透明。 还存在一种标准库以外的独立库，通俗地说这就是 x 或者说是“扩展库”。这种库包含了 Go 开发团队同时开发和维护的部分代码，但是不会与 Go 语言有相同的发布周期，并且相比于 Go 语言本身，兼容性也会较差（功能性和维护性也会较差）。其中的代码要么是实验性的（在未来可能会包含在标准库中），要么是比起标准库中的功能还不够泛用，或者是在某些罕见的情况下，提供一种开发者们可以与 Go 开发团队同步进行代码审查的方式。 再一次强调，如果没有额外地指出，在提到“标准库”时，我们指的是官方维护和发布的、托管在 golang.org 上的 Go 标准库。 代码构建工具我们需要代码构建工具来使 Go 语言易于使用。构建工具的主要职责是找到需要编译的包和所有的依赖项，并依据必要的参数调用编译器和链接器。Go 语言有对包的支持，允许在编译时把多个源代码文件视为一个单元。这也定义了导入和使用其他包的方式。但重要的是，这并没有定义导入包的路径与源文件的映射方式，也没有定义导入包在磁盘中的位置。因此，每种构建工具对于该问题都有不同的处理方式。你可以使用通用构建工具（如 Make 命令），但也有许多专门为 Go 语言而生的构建工具： Go 语言工具[1]是 Go 开发团队官方维护的构建工具。它与 Go 语言（gc 和标准库）有相同的发布周期。它需要一个名为 GOROOT 的目录（该值从环境变量中获取，会在安装时产生一个默认值）来存放编译器、标准库和其他各种工具。它要求所有的源代码都要存放在一个名为 GOPATH 的目录下（该值也从环境变量中获取，默认为 $HOME/go 或是一个与其相等的值）。举例来说，包 a/b 的源代码应该位于诸如 $GOPATH/src/a/b/c.go 的路径下。并且 $GOPATH/src/a/b 路径下应该只包含一个包下的源文件。在分布式的模式下，有一种机制可以从任意服务器上递归地下载某个包及其依赖项，即使这种机制不支持版本控制或是下载校验。Go 语言工具中也包含了许多其他工具包，包括用于测试 Go 代码的工具、阅读文档的工具（golang.org 是用 Go 语言工具部署的）、提交 bug 的工具和其他各种小工具。 gopherjs 自带的构建工具，它在很大程度上模仿了 Go 语言工具。 gomobile 是一个专门为移动操作系统构建 Go 代码的工具。 dep、gb、glide 等等是社区开发的构建和依赖项管理工具，它们各自都有自己独特的文件布局方式（有些可以与 Go 语言工具兼容，有些则不兼容）和依赖项声明方式。 bazel 是谷歌内部构建工具的开源版本。虽然它的使用实际上并不限于 Go 语言，但我之所以把它列为单独的一项，是因为人们常说 Go 语言工具旨在为谷歌服务，而与社区的需求相冲突。然而，Go 语言工具（和其他许多开放的工具）是无法被谷歌所使用的，原因是 bazel 使用了不兼容的文件布局方式。 代码构建工具是大多数用户在编写代码时直接使用的重要工具，因此它很大程度上决定了 Go 语言生态系统的方方面面，也决定了包的组合方式，这也将影响 Go 程序员之间的沟通和交流方式。如上所述，Go 语言工具是被隐式引用的（除非指定了其他的运行环境），因此它的设计会让公众对 “Go 语言”的看法造成很大的影响。虽然有许多替代工具可供使用，这些工具也已经在如公司内部使用等场景被广泛使用，但是开源社区通常希望 Go 语言工具与 Go 语言的使用方式相契合，这意味着： 可以获取源代码。Go 语言工具对包的二进制分发只做了极其有限的支持，并且仅有的支持将会在将来的版本中移除。 要依据 Go 官方文档编排格式来撰写文档。 要包含测试用例，并且能通过 go test 运行测试。 可以完全通过 go build 来编译（与后面所述的特征共同被称为“可以通过 Go 得到的” —— “go-gettable”）。特别指出，如果需要生成源代码或是元编程，则使用 go generate 并提交生成的构件。 通过命名空间导入的路径其第一部分是一个域名，该域名可以是一个代码托管服务器或者是该服务器上运行的一个 Web 服务，则 Go 代码可以找到源代码和其依赖，并且可以正常工作。 每个目录都只有一个包，并且可以使用代码构建约束条件进行条件编译。 Go 语言工具的文档非常全面，它是一个学习 Go 如何实现各种生态系统的良好起点。 其他工具Go 语言的标准库包含了一些可以与 Go 源代码交互的包和包含了更多功能的 x/tools 扩展库。Go 语言也因此在社区中有非常强的第三方工具开发文化（由于官方强烈地想要保持 Go 语言本身的精简）。这些工具通常需要知道源代码的位置，可能还需要获取类型信息。go/build 包遵循了 Go 语言工具的约定，因此它本身就可以作为其部分构建过程的文档。缺点则是，构建在它之上的工具有时与基于其他构建工具的代码不兼容。因此有一个新的包正在开发中，它可以与其他构建工具很好地集成。 实际上 Go 语言的工具有非常多，并且每个人都有自己的偏好。但大致如下： Go 语言开发团队所研发的工具，与 Go 语言有相同的发布周期。 它包含代码自动格式化工具、测试覆盖率工具、运行时追踪工具、信息收集工具、针对常见错误的静态分析器、一款已经废弃的 Go 代码升级工具。这些工具都可以通过 go tool &lt;cmd&gt; 命令来访问。 由 Go 开发团队所维护，但不随 Go 语言一起发布的工具。博客文章编写工具和演示工具、大型代码重构工具、导入路径自动修正工具和语言服务器。 第三方工具 —— 实在太多了。有很多关于第三方工具的列表，例如这个。 总结我想用一个简短的参考文献列表来结束这篇文章，列表的内容是为那些感到迷茫的初学者准备的。请点击下面的链接： 开始学习 Go 语言。 理解 Go 语言的工作方式。 什么是合法的 Go 代码及其原因。 Go 语言工具及其文档，也可以通过 go help 查看。有时会涉及到其他内容，你也可以查看这些不够精细的内容。 编写符合社区标准的代码。 对代码进行测试。 寻找新的依赖包或查看公用包的文档。 除此以外还有许多有价值的文档可以作为补充，但这些应该已经足够让你有一个良好的开端了。作为一个 Go 语言的初学者，如果你发现本文有任何遗漏之处（我可能会补充更多的细节）或者你找到了任何有价值的参考资料，请通过 Twitter 联系我。如果你已经是一个经验丰富的 Go 语言开发者，并且你发现我遗漏了某些重要的内容（但是我有意忽略了一些重要的参考资料，使得初学者们可以感受到 Go 语言学习中的新鲜感:smile:），也请给我留言。 [1] 注：Go 开发团队目前正在对模块做一些支持，模块是包之上的代码分发单元，这些支持包括版本控制和一些可以使“传统” Go 语言工具解决问题的基础工作。等这些支持完成以后，这一段中的所有内容基本上就都过时了。对模块的支持目前是有的，但还不是 Go 语言的一部分。由于本文的核心内容是对 Go 语言的不同组成部分进行简要介绍，这些内容是不太容易发生变化的，目前来看我认为理解这些历史问题也是很有必要的。 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。","link":"/zh-cn/a-bird-s-eye-view-of-go/"},{"title":"【译】用 Rust 打造你的第一个命令行工具","text":"原文地址：Your first CLI tool with Rust 原文作者：Jérémie Veillet 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/your-first-cli-tool-with-rust.md 译者：JackEggie 校对者：TloveYing 用 Rust 打造你的第一个命令行工具在精彩的编程世界里，你可能听说过这种名为 Rust 的新语言。它是一种开源的系统级编程语言。它专注于性能、内存安全和并行性。你可以像 C/C++ 那样用它编写底层应用程序。 你可能已经在 Web Assembly 网站上见到过它了。Rust 能够编译 WASM 应用程序，你可以在 Web Assembly FAQ 上找到很多例子。它也被认为是 servo 的基石，servo 是一个在 Firefox 中实现的高性能浏览器引擎。 这可能会让你望而却步，但这不是我们要在这里讨论的内容。我们将介绍如何使用它构建命令行工具，而你可能会从中发现很多有意思的东西。 为什么是 Rust？好吧，让我把事情说清楚。我本可以用任何其他语言或框架来完成命令行工具。我可以选 C、Go、Ruby 等等。甚至，我可以使用经典的 bash。 在 2018 年中，我想学习一些新东西，Rust 激发了我的好奇心，同时我也需要构建一些简单的小工具来自动化工作和个人项目中的一些流程。 安装你可以使用 Rustup 来设置你的开发环境，它是安装和配置你机器上所有的 Rust 工具的主要入口。 如果你在 Linux 和 MacOS 上工作，使用如下命令即可完成安装： 1$ curl &lt;https://sh.rustup.rs&gt; -sSf | sh 如果你使用的是 Windows 系统，同样地，你需要在 Rustup 网站上下载一个 exe 并运行。 如果你用的是 Windows 10，我建议你使用 WSL 来完成安装。以上就是安装所需的步骤，我们现在可以去创建我们的第一个 Rust 应用程序了！ 你的第一个 Rust 应用程序我们在这里要做的是，仿照 cat 来构建一个 UNIX 实用工具，或者至少是一个简化版本，我们称之为 kt。这个应用程序将接受一个文件路径作为输入，并在终端的标准输出中显示文件的内容。 要创建这个应用程序的基本框架，我们将使用一个名为 Cargo 的工具。它是 Rust 的包管理器，可以将它看作是 Rust 工具的 NPM（对于 Javascript 开发者）或 Bundler（对于 Ruby 开发者）。 打开你的终端，进入你想要存储源代码的路径下，然后输入下面的代码。 1$ cargo init kt 这将会创建一个名为 kt 的目录，该目录下已经有我们应用程序的基本结构了。 如果我们 cd 到该目录中，我们将看到这个目录结构。而且，方便的是，这个项目已经默认初始化了 git。真是太好了！ 123456789$ cd kt/ | .git/ | .gitignore | Cargo.toml | src/ Cargo.toml 文件包含了我们的应用程序的基本信息和依赖信息。同样地，可以把它看做应用程序的 package.json 或者 Gemfile 文件。 src/ 目录包含了应用程序的源文件，我们可以看到其中只有一个 main.rs 文件。检查文件的内容，我们可以看到其中只有一个 main 函数。 123fn main() &#123; println!(\"Hello, world!\");&#125; 试试构建这个项目。由于没有外部依赖，它应该会构建得非常快。 123$ cargo buildCompiling kt v0.1.0 (/Users/jeremie/Development/kitty)Finished dev [unoptimized + debuginfo] target(s) in 2.82s 在开发模式下，你可以通过调用 cargo run 来执行二进制文件（用 cargo run --- my_arg 来传递命令行参数）。 1234$ cargo runFinished dev [unoptimized + debuginfo] target(s) in 0.07sRunning `target/debug/kt`Hello, world! 恭喜你，你通过刚才的步骤已经创建并运行了你的第一个 Rust 应用程序了！🎉 解析第一个命令行参数正如我之前在文章中所说的，我们正在尝试构建一个简化版的 cat 命令。我们的目标是模拟 cat 的行为，运行 kt myfile.txt 命令之后，在终端输出文件内容。 我们本来可以自己处理参数的解析过程，但幸运的是，一个 Rust 工具可以帮我们简化这个过程，它就是 Clap。 这是一个高性能的命令行参数解析器，它让我们管理命令行参数变得很简单。 使用这个工具的第一步是打开 Cargo.toml 文件，并在其中添加指定的依赖项。如果你从未处理过 .toml 文件也没关系，它与 Windows 系统中的 .INI 文件极其相似。这种文件格式在 Rust 中是很常见的。 在这个文件中，你将看到有一些信息已经填充好了，比如作者、版本等等。我们只需要在 [dependencies] 下添加依赖项就行了。 12[dependencies]clap = \"~2.32\" 保存文件后，我们需要重新构建项目，以便能够使用依赖库。即使 cargo 下载了除 clap 以外的文件也不用担心，这是由于 clap 也有其所需的依赖关系。 12345678910111213141516171819202122$ cargo build Updating crates.io index Downloaded clap v2.32.0 Downloaded atty v0.2.11 Downloaded bitflags v1.0.4 Downloaded ansi_term v0.11.0 Downloaded vec_map v0.8.1 Downloaded textwrap v0.10.0 Downloaded libc v0.2.48 Downloaded unicode-width v0.1.5 Downloaded strsim v0.7.0 Compiling libc v0.2.48 Compiling unicode-width v0.1.5 Compiling strsim v0.7.0 Compiling bitflags v1.0.4 Compiling ansi_term v0.11.0 Compiling vec_map v0.8.1 Compiling textwrap v0.10.0 Compiling atty v0.2.11 Compiling clap v2.32.0 Compiling kt v0.1.0 (/home/jeremie/Development/kt) Finished dev [unoptimized + debuginfo] target(s) in 33.92s 以上就是需要配置的内容，接下来我们可以动手，写一些代码来读取我们的第一个命令行参数。 打开 main.rs 文件。我们必须显式地声明我们要使用 Clap 库。 12345extern crate clap;use clap::&#123;Arg, App&#125;;fn main() &#123;&#125; extern crate 关键字用于导入依赖库，你只需将其添加到主文件中，应用程序的任何源文件就都可以引用它了。use 部分则是指你将在这个文件中使用 clap 的哪个模块。 Rust 模块（module）的简要说明： Rust 有一个模块系统，能够以有组织的方式重用代码。模块是一个包含函数或类型定义的命名空间，你可以选择这些定义是否在其模块外部可见（public/private）。—— Rust 文档 这里我们声明的是我们想要使用 Arg 和 App 模块。我们希望我们的应用程序有一个 FILE 参数，它将包含一个文件路径。Clap 可以帮助我们快速实现该功能。这里使用了一种链式调用方法的方式，这是一种令人非常愉悦的方式。 1234567891011fn main() &#123; let matches = App::new(\"kt\") .version(\"0.1.0\") .author(\"Jérémie Veillet. jeremie@example.com\") .about(\"A drop in cat replacement written in Rust\") .arg(Arg::with_name(\"FILE\") .help(\"File to print.\") .empty_values(false) ) .get_matches();&#125; 再次编译并执行，除了变量 matches 上的编译警告（对于 Ruby 开发者来说，可以在变量前面加上 _，它会告诉编译器该变量是可选的），它应该不会输出太多其他信息。 如果你向应用程序传递 -h 或者 -V 参数，程序会自动生成一个帮助信息和版本信息。我不知道你如何看待这个事情，但我觉得它 🔥🔥🔥。 123456789101112131415161718192021$ cargo run -- -h Finished dev [unoptimized + debuginfo] target(s) in 0.03s Running `target/debug/kt -h`kt 0.1.0Jérémie Veillet. jeremie@example.comA drop-in cat replacement written in Rust USAGE: kt [FILE] FLAGS: -h, --help Prints help information -V, --version Prints version information ARGS: &lt;FILE&gt; File to print.$ cargo run --- -VFinished dev [unoptimized + debuginfo] target(s) in 0.04sRunning target/debug/kt -Vkt 0.1.0 我们还可以尝试不带任何参数，启动程序，看看会发生什么。 123$ cargo run --Finished dev [unoptimized + debuginfo] target(s) in 0.03s Running `target/debug/kt` 什么都没有发生。这是每次构建命令行工具时应该发生的默认行为。我认为不向应用程序传递任何参数就永远不应该触发任何操作。即使有时候这并不正确，但是在大多数情况下，永远不要执行用户从未打算执行的操作。 现在我们已经有了参数，我们可以深入研究如何捕获这个命令行参数并在标准输出中显示一些内容。 要实现这一点，我们可以使用 clap 中的 value_of 方法。请参考文档来了解该方法是怎么运作的。 123456789101112131415fn main() &#123; let matches = App::new(\"kt\") .version(\"0.1.0\") .author(\"Jérémie Veillet. jeremie@example.com\") .about(\"A drop in cat replacement written in Rust\") .arg(Arg::with_name(\"FILE\") .help(\"File to print.\") .empty_values(false) ) .get_matches(); if let Some(file) = matches.value_of(\"FILE\") &#123; println!(\"Value for file argument: &#123;&#125;\", file); &#125;&#125; 此时，你可以运行应用程序并传入一个随机字符串作为参数，在你的控制台中会回显该字符串。 1234$ cargo run -- test.txtFinished dev [unoptimized + debuginfo] target(s) in 0.02s Running `target/debug/kt test.txt`Value for file argument: test.txt 请注意，目前我们实际上没有对该文件是否存在进行验证。那么我们应该怎么实现呢？ 有一个标准库可以让我们检查一个文件或目录是否存在，使用方式非常简单。它就是 std::path 库。它有一个 exists 方法，可以帮我们检查文件是否存在。 如前所述，使用 use 关键字来添加依赖库，然后编写如下代码。你可以看到，我们使用 If-Else 条件控制在输出中打印一些文本。println! 方法会写入标准输出 stdout，而 eprintln! 会写入标准错误输出 stderr。 12345678910111213141516171819202122232425262728extern crate clap;use clap::&#123;Arg, App&#125;;use std::path::Path;use std::process; fn main() &#123; let matches = App::new(\"kt\") .version(\"0.1.0\") .author(\"Jérémie Veillet. jeremie@example.com\") .about(\"A drop in cat replacement written in Rust\") .arg(Arg::with_name(\"FILE\") .help(\"File to print.\") .empty_values(false) ) .get_matches(); if let Some(file) = matches.value_of(\"FILE\") &#123; println!(\"Value for file argument: &#123;&#125;\", file); if Path::new(&amp;file).exists() &#123; println!(\"File exist!!\"); &#125; else &#123; eprintln!(\"[kt Error] No such file or directory.\"); process::exit(1); // 程序错误终止时的标准退出码 &#125; &#125;&#125; 我们快要完成了！现在我们需要读取文件的内容并将结果显示在 stdout 中。 同样，我们将使用一个名为 File 的标准库来读取文件。我们将使用 open 方法读取文件的内容，然后将其写入一个字符串对象，该对象将在 stdout 中显示。 1234567891011121314151617181920212223242526272829303132extern crate clap;use clap::&#123;Arg, App&#125;;use std::path::Path;use std::process;use std::fs::File;use std::io::&#123;Read&#125;;fn main() &#123; let matches = App::new(\"kt\") .version(\"0.1.0\") .author(\"Jérémie Veillet. jeremie@example.com\") .about(\"A drop in cat replacement written in Rust\") .arg(Arg::with_name(\"FILE\") .help(\"File to print.\") .empty_values(false) ) .get_matches(); if let Some(file) = matches.value_of(\"FILE\") &#123; if Path::new(&amp;file).exists() &#123; println!(\"File exist!!\"); let mut f = File::open(file).expect(\"[kt Error] File not found.\"); let mut data = String::new(); f.read_to_string(&amp;mut data).expect(\"[kt Error] Unable to read the file.\"); println!(\"&#123;&#125;\", data); &#125; else &#123; eprintln!(\"[kt Error] No such file or directory.\"); process::exit(1); &#125; &#125;&#125; 再次构建并运行此代码。恭喜你！我们现在有一个功能完整的工具了！🍾 12345678910111213141516171819202122232425262728293031323334353637383940$ cargo build Compiling kt v0.1.0 (/home/jeremie/Development/kt) Finished dev [unoptimized + debuginfo] target(s) in 0.70s$ cargo run -- ./src/main.rs Finished dev [unoptimized + debuginfo] target(s) in 0.03s Running `target/debug/kt ./src/main.rs`File exist!!extern crate clap;use clap::&#123;Arg, App&#125;;use std::path::Path;use std::process;use std::fs::File;use std::io::&#123;Read&#125;; fn main() &#123; let matches = App::new(\"kt\") .version(\"0.1.0\") .author(\"Jérémie Veillet. jeremie@example.com\") .about(\"A drop in cat replacement written in Rust\") .arg(Arg::with_name(\"FILE\") .help(\"File to print.\") .empty_values(false) ) .get_matches(); if let Some(file) = matches.value_of(\"FILE\") &#123; if Path::new(&amp;file).exists() &#123; println!(\"File exist!!\"); let mut f = File::open(file).expect(\"[kt Error] File not found.\"); let mut data = String::new(); f.read_to_string(&amp;mut data).expect(\"[kt Error] Unable to read the file.\"); println!(\"&#123;&#125;\", data); &#125; else &#123; eprintln!(\"[kt Error] No such file or directory.\"); process::exit(1); &#125; &#125;&#125; 改进一点点我们的应用程序现可以接收一个参数并在 stdout 中显示结果。 我们可以稍微调整一下整个打印阶段的性能，方法是用 writeln! 来代替 println!。这在 Rust 输出教程中有很好的解释。在此过程中，我们可以清理一些代码，删除不必要的打印，并对可能的错误场景进行微调。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647extern crate clap;use clap::&#123;Arg, App&#125;;use std::path::Path;use std::process;use std::fs::File;use std::io::&#123;Read, Write&#125;;fn main() &#123; let matches = App::new(\"kt\") .version(\"0.1.0\") .author(\"Jérémie Veillet. jeremie@example.com\") .about(\"A drop in cat replacement written in Rust\") .arg(Arg::with_name(\"FILE\") .help(\"File to print.\") .empty_values(false) ) .get_matches(); if let Some(file) = matches.value_of(\"FILE\") &#123; if Path::new(&amp;file).exists() &#123; match File::open(file) &#123; Ok(mut f) =&gt; &#123; let mut data = String::new(); f.read_to_string(&amp;mut data).expect(\"[kt Error] Unable to read the file.\"); let stdout = std::io::stdout(); // 获取全局 stdout 对象 let mut handle = std::io::BufWriter::new(stdout); // 可选项：将 handle 包装在缓冲区中 match writeln!(handle, \"&#123;&#125;\", data) &#123; Ok(_res) =&gt; &#123;&#125;, Err(err) =&gt; &#123; eprintln!(\"[kt Error] Unable to display the file contents. &#123;:?&#125;\", err); process::exit(1); &#125;, &#125; &#125; Err(err) =&gt; &#123; eprintln!(\"[kt Error] Unable to read the file. &#123;:?&#125;\", err); process::exit(1); &#125;, &#125; &#125; else &#123; eprintln!(\"[kt Error] No such file or directory.\"); process::exit(1); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$ cargo run -- ./src/main.rs Finished dev [unoptimized + debuginfo] target(s) in 0.02s Running `target/debug/kt ./src/main.rs`extern crate clap;use clap::&#123;Arg, App&#125;;use std::path::Path;use std::process;use std::fs::File;use std::io::&#123;Read, Write&#125;; fn main() &#123; let matches = App::new(\"kt\") .version(\"0.1.0\") .author(\"Jérémie Veillet. jeremie@example.com\") .about(\"A drop in cat replacement written in Rust\") .arg(Arg::with_name(\"FILE\") .help(\"File to print.\") .empty_values(false) ) .get_matches(); if let Some(file) = matches.value_of(\"FILE\") &#123; if Path::new(&amp;file).exists() &#123; match File::open(file) &#123; Ok(mut f) =&gt; &#123; let mut data = String::new(); f.read_to_string(&amp;mut data).expect(\"[kt Error] Unable to read the file.\"); let stdout = std::io::stdout(); // 获取全局 stdout 对象 let mut handle = std::io::BufWriter::new(stdout); // 可选项：将 handle 包装在缓冲区中 match writeln!(handle, \"&#123;&#125;\", data) &#123; Ok(_res) =&gt; &#123;&#125;, Err(err) =&gt; &#123; eprintln!(\"[kt Error] Unable to display the file contents. &#123;:?&#125;\", err); process::exit(1); &#125;, &#125; &#125; Err(err) =&gt; &#123; eprintln!(\"[kt Error] Unable to read the file. &#123;:?&#125;\", err); process::exit(1); &#125;, &#125; &#125; else &#123; eprintln!(\"[kt Error] No such file or directory.\"); process::exit(1); &#125; &#125;&#125; 我们完成了！我们通过约 45 行代码就完成了我们的简化版 cat 命令 🤡，并且它表现得非常好！ 构建独立的应用程序那么构建这个应用程序并将其安装到文件系统中要怎么做呢？向 cargo 寻求帮助吧！ cargo build 接受一个 ---release 标志位，以便我们可以指定我们想要的可执行文件的最终版本。 123456789101112$ cargo build --release Compiling libc v0.2.48 Compiling unicode-width v0.1.5 Compiling ansi_term v0.11.0 Compiling bitflags v1.0.4 Compiling vec_map v0.8.1 Compiling strsim v0.7.0 Compiling textwrap v0.10.0 Compiling atty v0.2.11 Compiling clap v2.32.0 Compiling kt v0.1.0 (/home/jeremie/Development/kt) Finished release [optimized] target(s) in 28.17s 生成的可执行文件位于该子目录中：./target/release/kt。 你可以将这个文件复制到你的 PATH 环境变量中，或者使用一个 cargo 命令来自动安装。应用程序将安装在 ~/.cargo/bin/ 目录中（确保该目录在 ~/.bashrc 或 ~/.zshrc 的 PATH 环境变量中）。 1234$ cargo install --path . Installing kt v0.1.0 (/home/jeremie/Development/kt) Finished release [optimized] target(s) in 0.03s Installing /home/jeremie/.cargo/bin/kt 现在我们可以直接在终端中使用 kt 命令调用我们的应用程序了！\\o/ 12$ kt -Vkt 0.1.0 总结我们创建了一个仅有数行 Rust 代码的命令行小工具，它接受一个文件路径作为输入，并在 stdout 中显示该文件的内容。 你可以在这个 GitHub 仓库中找到这篇文章中的所有源代码。 轮到你来改进这个工具了！ 你可以添加一个命令行参数来控制是否在输出中添加行号（-n 选项）。 只显示文件的一部分，然后通过按键盘上的 ENTER 键来显示其余部分。 使用 kt myfile.txt myfile2.txt myfile3.txt 这样的语法一次性打开多个文件。 不要犹豫，告诉我你用它做了什么！😎 特别感谢帮助修订这篇文章的 Anaïs 👍 进一步探索 cat：cat 实用程序的 Wikipedia 页面。 kt-rs Rust Cookbook Clap：一个功能齐全、高性能的 Rust 命令行参数解析器。 Reqwest：一个简单而功能强大的 Rust HTTP 客户端。 Serde：一个 Rust 的序列化框架。 crates.io: Rust 社区的工具注册站点。 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。","link":"/zh-cn/your-first-cli-tool-with-rust/"},{"title":"浮躁、静不下心的解决方案","text":"前言最近临近离职，空闲的时间比较多，但是也还是不知道如何静下心来去做一些一直都想去完成的事情。思考后的结果就是觉得太过于浮躁，需要改变些什么才能有动力去做，既然改变本身就是一种动力，那么就要思考一下怎么去改变了。 浮躁的来源从人类本身的角度来看，奖励机制的过度使用才是浮躁的根本原因。这里的奖励机制就是小白鼠被点击后会产生多巴胺的机制。这种机制是感性的，被刺激到了就会觉得很开心，即使本身并没有什么意义。这种机制存在的意义是对人类的繁衍很有帮助，包括美食与性，都是这种奖励机制的正反馈。 但是在人类社会中生存，这种机制很多时候都在帮倒忙。例如，游戏是奖励机制最好的例子，你忍不住就想把今天的任务做完，领了奖励美滋滋。但是做任务这事本身就对社会中的你的成长没有太大的帮助。包括现在的很多社区的文章，都是让大家看着很开心，很满足，但是对提升自己没有什么帮助。 因此，如何在这个信息爆炸的时代过滤出有意义的信息就变得比较关键了。 解决方案首先，没有意志力而去做出改变的都是空谈。 解决方案的原理是将平时刺激奖励中枢的事情变成对其的负反馈。即想玩游戏刷手机的时候，还是可以去做，但是在玩之前，要思考玩游戏是没有意义的，玩之后，要思考玩游戏的时候很开心，之后也仍然会比较空虚。 其次，也要相应地在生活中做出改变。比如，坚持运动和冥想，早睡早起，少刷手机，多学习多思考等等。坚持的技巧也是很重要的，比如，创造只有学习氛围的环境，多做笔记多把自己的想法记录下来等等。 后记好了，我自己有一个改变的计划了。也许计划会再调整，但是我会让自己不再那么浮躁的。","link":"/zh-cn/fickleness/"}],"tags":[{"name":"java","slug":"java","link":"/zh-cn/tags/java/"},{"name":"cache","slug":"cache","link":"/zh-cn/tags/cache/"},{"name":"redis","slug":"redis","link":"/zh-cn/tags/redis/"},{"name":"hexo","slug":"hexo","link":"/zh-cn/tags/hexo/"},{"name":"github","slug":"github","link":"/zh-cn/tags/github/"},{"name":"psychology","slug":"psychology","link":"/zh-cn/tags/psychology/"},{"name":"git","slug":"git","link":"/zh-cn/tags/git/"},{"name":"html","slug":"html","link":"/zh-cn/tags/html/"},{"name":"search engine","slug":"search-engine","link":"/zh-cn/tags/search-engine/"},{"name":"jvm","slug":"jvm","link":"/zh-cn/tags/jvm/"},{"name":"json","slug":"json","link":"/zh-cn/tags/json/"},{"name":"performance","slug":"performance","link":"/zh-cn/tags/performance/"},{"name":"frontend","slug":"frontend","link":"/zh-cn/tags/frontend/"},{"name":"open source","slug":"open-source","link":"/zh-cn/tags/open-source/"},{"name":"agile","slug":"agile","link":"/zh-cn/tags/agile/"},{"name":"scrum","slug":"scrum","link":"/zh-cn/tags/scrum/"},{"name":"algorithm","slug":"algorithm","link":"/zh-cn/tags/algorithm/"},{"name":"multi-thread","slug":"multi-thread","link":"/zh-cn/tags/multi-thread/"},{"name":"gold-miner","slug":"gold-miner","link":"/zh-cn/tags/gold-miner/"},{"name":"translation","slug":"translation","link":"/zh-cn/tags/translation/"},{"name":"spring","slug":"spring","link":"/zh-cn/tags/spring/"},{"name":"python","slug":"python","link":"/zh-cn/tags/python/"},{"name":"ai","slug":"ai","link":"/zh-cn/tags/ai/"},{"name":"management","slug":"management","link":"/zh-cn/tags/management/"},{"name":"go-lang","slug":"go-lang","link":"/zh-cn/tags/go-lang/"},{"name":"rust","slug":"rust","link":"/zh-cn/tags/rust/"},{"name":"fickleness","slug":"fickleness","link":"/zh-cn/tags/fickleness/"}],"categories":[]}