<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>标签: gold-miner - Jack&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta property="og:type" content="website">
<meta property="og:title" content="Jack&#39;s Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;jackeggie.github.io&#x2F;tags&#x2F;gold-miner&#x2F;index.html">
<meta property="og:site_name" content="Jack&#39;s Blog">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">





<link rel="icon" href="/images/avatar.jpeg">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-108548768-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-108548768-1');
</script>


    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    Jack&#39;s Blog
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/tags">Tags</a>
            
            <a class="navbar-item "
               href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;" target="_blank" rel="noopener">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/JackEggie" target="_blank" rel="noopener">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5>#gold-miner</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019-07-25-a-bird-s-eye-view-of-go/" itemprop="url">【译】Go 语言概览</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-07-25T10:49:21.000Z" itemprop="datePublished">7月 25 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            34 分钟 读完 (约 5069 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<ul>
<li>原文地址：<a href="https://blog.merovius.de/2019/06/12/birdseye-go.html" target="_blank" rel="noopener">A bird’s eye view of Go</a></li>
<li>原文作者：<a href="https://blog.merovius.de" target="_blank" rel="noopener">Axel Wagner</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/birdseye-go.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/birdseye-go.md</a></li>
<li>译者：<a href="https://github.com/JackEggie" target="_blank" rel="noopener">JackEggie</a></li>
<li>校对者：<a href="https://github.com/40m41h42t" target="_blank" rel="noopener">40m41h42t</a>, <a href="https://github.com/JalanJiang" target="_blank" rel="noopener">JalanJiang</a></li>
</ul>
</blockquote>
<h1 id="Go-语言概览"><a href="#Go-语言概览" class="headerlink" title="Go 语言概览"></a>Go 语言概览</h1><p><strong>本文摘要：本文非常笼统地总结了 Go 语言的定义、生态系统和实现方式，也尽力给出了与不同的需求所对应的参考文档，详情参见本文末尾。</strong></p>
<p>每当我们说起“Go 语言”的时候，可能会因为场景的不同聊到很多完全不同的东西。因此，我尝试着对 Go 语言和其生态系统做一个概述，并在各部分内容中都列出相关的文档（这可能有点像是大杂烩，其中还包含了我最近实际遇到的许多问题）。让我们开始吧：</p>
<h4 id="Go-编程语言"><a href="#Go-编程语言" class="headerlink" title="Go 编程语言"></a>Go 编程语言</h4><p>Go 语言是一种编程语言。作为一种权威，<a href="https://golang.org/ref/spec" target="_blank" rel="noopener">Go 语言规范</a>中定义了代码的格式规范和代码所代表的含义。不符合该规范的都不是 Go 语言。同样地，该规范中<strong>没有</strong>提到的内容不视为该语言的一部分。目前由 Go 语言开发团队维护该规范，每半年发布一个新版本。在我写这篇文章的时候最新的版本是 <code>1.12</code>。</p>
<p>Go 语言规范规定了：</p>
<ul>
<li>语法</li>
<li>变量的类型、值，及其语义</li>
<li>预先声明的标识符及其含义</li>
<li>Go 程序的运行方式</li>
<li>特殊的 <a href="https://golang.org/ref/spec#Package_unsafe" target="_blank" rel="noopener">unsafe 包</a>（虽然没有包含所有的语义）</li>
</ul>
<p>该规范<strong>应该</strong>已经足够让你实现一个 Go 语言的编译器了。实际上，已经有很多人基于此实现了许多不同的编译器。</p>
<h4 id="Go-编译器及其运行时"><a href="#Go-编译器及其运行时" class="headerlink" title="Go 编译器及其运行时"></a>Go 编译器及其运行时</h4><p>该语言规范只是一份文本文档，它本身不太有用。你需要的是实现了这些语义的软件，即编译器（分析、检查源代码，并将其转换为可执行的形式）和运行时（提供运行代码时所需的环境）。有很多这样的软件组合，他们都或多或少有些不同。示例如下：</p>
<ul>
<li><code>gc</code>，Go 语言开发团队自己开发的纯 Go 语言实现的（有一小部分汇编实现）编译器和运行时。它随着 Go 语言一起发布。与其他此类工具不同的是，<code>gc</code> 并不<strong>严格</strong>区分编译器、组装器和链接器 —— 它们在实现的时候共享了大量的代码，并且会共享或传递一些重要职责。因此，通常无法链接由不同版本的 <code>gc</code> 所编译的包。</li>
<li><a href="https://golang.org/doc/install/gccgo" target="_blank" rel="noopener">gccgo 和 libgo</a>，gcc 的前端和其运行时。它是用 C 实现的，并且也由 Go 开发团队维护。然而，由于它是 gcc 组织的一部分，并根据 gcc 的发布周期发布，因此通常会稍微落后于 Go 语言规范的“最新”版本。</li>
<li><a href="https://llvm.org/svn/llvm-project/llgo/trunk/README.TXT" target="_blank" rel="noopener">llgo</a>，LLVM 的前端。我对其不太了解。</li>
<li><a href="https://github.com/gopherjs/gopherjs" target="_blank" rel="noopener">gopherjs</a>，将 Go 代码编译为 JavaScript，并使用一个 JavaScript VM 和一些自定义代码作为运行时。长远来看，由于 <code>gc</code> 获得了 WebAssembly 的原生支持，它有可能会被淘汰。</li>
<li><a href="https://tinygo.org/" target="_blank" rel="noopener">tinygo</a>，针对小规模编程的不完整实现。它可以通过自定义一个运行时运行在微控制器（裸机）或者 WebAssembly 虚拟机上。由于它的局限性，<strong>技术上来说</strong>它并没有实现 Go 语言的所有特性 —— 主要体现在它缺少垃圾回收器、并发和反射。</li>
</ul>
<p>还有更多其他的实现，但这已经足以让你了解不同的实现方式。以上每一种方法都使用了不同的方式来实现 Go 语言，并具有自己与众不同的特性。他们可能存在的不同之处有（为了说明这一点，下面的某些说法可能会有点奇特）：</p>
<ul>
<li><code>int</code>/<code>uint</code> 的大小 —— 长度可能为 32 位或 64 位。</li>
<li>运行时中基础功能的实现方式，如内存分配、垃圾回收和并发的实现。</li>
<li>遍历 <code>map</code> 的顺序并没有在 Go 语言中定义 —— <code>gc</code> 显然会将这类操作随机化，而 <code>gopherjs</code> 会用你使用的 JavaScript 实现遍历。</li>
<li><code>append</code> 操作分配的所需额外内存空间大小 —— 但是，<strong>在分配额外空间时</strong>，<strong>不会</strong>再次分配更多的内存空间。</li>
<li><code>unsafe.Pointer</code> 与 <code>uintptr</code> 之间的转换方式。特别指出，<code>gc</code> 对于该转换何时应该生效有自己的<a href="https://godoc.org/unsafe#Pointer" target="_blank" rel="noopener">规则</a>。通常情况下，<code>unsafe</code> 包是虚拟的，它会在编译器中被实现。</li>
</ul>
<p>一般来说，根据规范中没有提到的某些细节（尤其是上面提到的那些细节）可以使你的程序用不同的编译器也能<strong>编译</strong>，但往往程序不会像你预期的那样<strong>正常工作</strong>。因此，你应该尽力避免此类事情发生。</p>
<p>如果你的 Go 语言是通过“正常”渠道安装的话（在官网上下载安装，或是通过软件包管理器安装），那么你会得到 Go 开发团队提供的 <code>gc</code> 和正式的运行时。在本文中，当我们在讨论“Go 是如何做的”时，若没有在上下文特别指明，我们通常就是在谈论 <code>gc</code>。因为它是最重要的一个实现。</p>
<h4 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h4><p><a href="https://golang.org/pkg/#stdlib" target="_blank" rel="noopener">标准库</a>是 Go 语言中附带的一组依赖包，它可以被用来立即构建许多实用的应用程序。它也由 Go 开发团队维护，并且会随着 Go 语言和编译器一起发布。一般来说，标准库的某种实现只能依赖与其共同发布的编译器才能正常使用。因为大部分（但不是所有）运行时都是标准库的一部分（主要包含在 <code>runtime</code>、<code>reflect</code>、<code>syscall</code> 包中）。由于编译器在编译时需要兼容当前使用的运行时，因此它们的版本要相同。标准库的 <strong>API</strong> 是稳定的，不会以不兼容的方式改变，所以基于某个指定版本的标准库编写的 Go 程序在编译器的未来版本中也可以正常运行。</p>
<p>有些标准库会完全自己实现整个库中的所有内容，而有些则只实现一部分 —— 开发者尤其会在 <code>runtime</code>、<code>reflect</code>、<code>unsafe</code> 和 <code>syscall</code> 包中实现自定义的功能。举个例子，我相信 <a href="https://cloud.google.com/appengine/docs/standard/go/" target="_blank" rel="noopener">AppEngine 标准库</a>是出于安全考虑重新实现了标准库的部分功能的。这类重新实现的部分通常会尽量对用户保持透明。</p>
<p>还存在一种<a href="https://golang.org/pkg/#subrepo" target="_blank" rel="noopener">标准库以外的独立库</a>，通俗地说这就是 <code>x</code> 或者说是“扩展库”。这种库包含了 Go 开发团队同时开发和维护的部分代码，但是<strong>不会</strong>与 Go 语言有相同的发布周期，并且相比于 <a href="https://golang.org/doc/go1compat" target="_blank" rel="noopener">Go 语言本身</a>，兼容性也会较差（功能性和维护性也会较差）。其中的代码要么是实验性的（在未来可能会包含在标准库中），要么是比起标准库中的功能还不够泛用，或者是在某些罕见的情况下，提供一种开发者们可以与 Go 开发团队同步进行代码审查的方式。</p>
<p>再一次强调，如果没有额外地指出，在提到“标准库”时，我们指的是官方维护和发布的、托管在 <a href="https://golang.org/pkg" target="_blank" rel="noopener">golang.org</a> 上的 Go 标准库。</p>
<h4 id="代码构建工具"><a href="#代码构建工具" class="headerlink" title="代码构建工具"></a>代码构建工具</h4><p>我们需要代码构建工具来使 Go 语言易于使用。构建工具的主要职责是找到需要编译的包和所有的依赖项，并依据必要的参数调用编译器和链接器。Go 语言有<a href="https://golang.org/ref/spec#Packages" target="_blank" rel="noopener">对包的支持</a>，允许在编译时把多个源代码文件视为一个单元。这也定义了导入和使用其他包的方式。但重要的是，这并没有定义导入包的路径与源文件的映射方式，也没有定义导入包在磁盘中的位置。因此，每种构建工具对于该问题都有不同的处理方式。你可以使用通用构建工具（如 Make 命令），但也有许多专门为 Go 语言而生的构建工具：</p>
<ul>
<li><a href="https://golang.org/cmd/go/" target="_blank" rel="noopener">Go 语言工具</a><sup><a href="#note1">[1]</a></sup>是 Go 开发团队官方维护的构建工具。它与 Go 语言（<code>gc</code> 和标准库）有相同的发布周期。它需要一个名为 <code>GOROOT</code> 的目录（该值从环境变量中获取，会在安装时产生一个默认值）来存放编译器、标准库和其他各种工具。它要求所有的源代码都要存放在一个名为 <code>GOPATH</code> 的目录下（该值也从环境变量中获取，默认为 <code>$HOME/go</code> 或是一个与其相等的值）。举例来说，包 <code>a/b</code> 的源代码应该位于诸如 <code>$GOPATH/src/a/b/c.go</code> 的路径下。并且 <code>$GOPATH/src/a/b</code> 路径下应该<strong>只</strong>包含一个包下的源文件。在分布式的模式下，有一种机制可以<a href="https://golang.org/cmd/go/#hdr-Remote_import_paths" target="_blank" rel="noopener">从任意服务器上递归地下载某个包及其依赖项</a>，即使这种机制不支持版本控制或是下载校验。Go 语言工具中也包含了许多其他工具包，包括用于测试 Go 代码的工具、阅读文档的工具（<a href="https://golang.org" target="_blank" rel="noopener">golang.org</a> 是用 Go 语言工具部署的）、提交 bug 的工具和其他各种小工具。</li>
<li><a href="https://github.com/gopherjs/gopherjs" target="_blank" rel="noopener">gopherjs</a> 自带的构建工具，它在很大程度上模仿了 Go 语言工具。</li>
<li><a href="https://github.com/golang/go/wiki/Mobile" target="_blank" rel="noopener">gomobile</a> 是一个专门为移动操作系统构建 Go 代码的工具。</li>
<li><a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a>、<a href="https://getgb.io/" target="_blank" rel="noopener">gb</a>、<a href="https://glide.sh/" target="_blank" rel="noopener">glide</a> 等等是社区开发的构建和依赖项管理工具，它们各自都有自己独特的文件布局方式（有些可以与 Go 语言工具兼容，有些则不兼容）和依赖项声明方式。</li>
<li><a href="https://bazel.build/" target="_blank" rel="noopener">bazel</a> 是谷歌内部构建工具的开源版本。虽然它的使用实际上并不限于 Go 语言，但我之所以把它列为单独的一项，是因为人们常说 Go 语言工具旨在为谷歌服务，而与社区的需求相冲突。然而，Go 语言工具（和其他许多开放的工具）是无法被谷歌所使用的，原因是 bazel 使用了不兼容的文件布局方式。</li>
</ul>
<p>代码构建工具是大多数用户在编写代码时直接使用的重要工具，因此它很大程度上决定了 <strong>Go 语言生态系统</strong>的方方面面，也决定了包的组合方式，这也将影响 Go 程序员之间的沟通和交流方式。如上所述，Go 语言工具是被隐式引用的（除非指定了其他的运行环境），因此它的设计会让公众对 “Go 语言”的看法造成很大的影响。虽然有许多替代工具可供使用，这些工具也已经在如公司内部使用等场景被广泛使用，但是开源社区<strong>通常</strong>希望 Go 语言工具与 Go 语言的使用方式相契合，这意味着：</p>
<ul>
<li>可以获取源代码。Go 语言工具对包的二进制分发只做了极其有限的支持，并且仅有的支持将会在将来的版本中移除。</li>
<li>要依据 <a href="https://blog.golang.org/godoc-documenting-go-code" target="_blank" rel="noopener">Go 官方文档编排格式</a>来撰写文档。</li>
<li>要<a href="https://golang.org/pkg/testing/#pkg-overview" target="_blank" rel="noopener">包含测试用例</a>，并且能通过 <code>go test</code> 运行测试。</li>
<li>可以完全通过 <code>go build</code> 来编译（与后面所述的特征共同被称为“可以通过 Go 得到的” —— “go-gettable”）。特别指出，如果需要生成源代码或是元编程，则使用 <a href="https://golang.org/pkg/cmd/go/internal/generate/" target="_blank" rel="noopener">go generate</a> 并提交生成的构件。</li>
<li>通过命名空间导入的路径其第一部分是一个域名，该域名可以是一个代码托管服务器或者是该服务器上运行的一个 Web 服务，则 Go 代码可以找到源代码和其依赖，并且可以<a href="https://golang.org/cmd/go/#hdr-Remote_import_paths" target="_blank" rel="noopener">正常工作</a>。</li>
<li>每个目录都只有一个包，并且可以使用<a href="https://golang.org/pkg/go/build/#hdr-Build_Constraints" target="_blank" rel="noopener">代码构建约束条件</a>进行条件编译。</li>
</ul>
<p><a href="https://golang.org/cmd/go" target="_blank" rel="noopener">Go 语言工具的文档</a>非常全面，它是一个学习 Go 如何实现各种生态系统的良好起点。</p>
<h4 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h4><p>Go 语言的标准库包含了<a href="https://golang.org/pkg/go/" target="_blank" rel="noopener">一些可以与 Go 源代码交互的包</a>和<a href="https://godoc.org/golang.org/x/tools/go" target="_blank" rel="noopener">包含了更多功能的 x/tools 扩展库</a>。Go 语言也因此在社区中有非常强的第三方工具开发文化（由于官方强烈地想要保持 Go 语言本身的精简）。这些工具通常需要知道源代码的位置，可能还需要获取类型信息。<a href="https://golang.org/pkg/go/build/" target="_blank" rel="noopener">go/build</a> 包遵循了 Go 语言工具的约定，因此它本身就可以作为其部分构建过程的文档。缺点则是，构建在它之上的工具有时与基于其他构建工具的代码不兼容。因此有<a href="https://godoc.org/golang.org/x/tools/go/packages" target="_blank" rel="noopener">一个新的包正在开发中</a>，它可以与其他构建工具很好地集成。</p>
<p>实际上 Go 语言的工具有非常多，并且每个人都有自己的偏好。但大致如下：</p>
<ul>
<li><a href="https://golang.org/cmd/" target="_blank" rel="noopener">Go 语言开发团队所研发的工具，与 Go 语言有相同的发布周期</a>。</li>
<li>它包含<a href="https://golang.org/cmd/gofmt/" target="_blank" rel="noopener">代码自动格式化工具</a>、<a href="https://golang.org/cmd/cover/" target="_blank" rel="noopener">测试覆盖率工具</a>、<a href="https://golang.org/cmd/trace/" target="_blank" rel="noopener">运行时追踪工具</a>、<a href="https://golang.org/cmd/pprof/" target="_blank" rel="noopener">信息收集工具</a>、<a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener">针对常见错误的静态分析器</a>、<a href="https://golang.org/cmd/fix/" target="_blank" rel="noopener">一款已经废弃的 Go 代码升级工具</a>。这些工具都可以通过 <code>go tool &lt;cmd&gt;</code> 命令来访问。</li>
<li><a href="https://godoc.org/golang.org/x/tools/cmd" target="_blank" rel="noopener">由 Go 开发团队所维护，但不随 Go 语言一起发布的工具</a>。<a href="https://godoc.org/golang.org/x/tools/cmd/present" target="_blank" rel="noopener">博客文章编写工具和演示工具</a>、<a href="https://godoc.org/golang.org/x/tools/cmd/eg" target="_blank" rel="noopener">大型代码重构工具</a>、<a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">导入路径自动修正工具</a>和<a href="https://godoc.org/golang.org/x/tools/cmd/gopls" target="_blank" rel="noopener">语言服务器</a>。</li>
<li>第三方工具 —— 实在太多了。有很多关于第三方工具的列表，例如<a href="https://github.com/avelino/awesome-go#tools" target="_blank" rel="noopener">这个</a>。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我想用一个简短的参考文献列表来结束这篇文章，列表的内容是为那些感到迷茫的初学者准备的。请点击下面的链接：</p>
<ul>
<li><a href="https://tour.golang.org/welcome/1" target="_blank" rel="noopener">开始学习 Go 语言</a>。</li>
<li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">理解 Go 语言的工作方式</a>。</li>
<li><a href="https://golang.org/ref/spec" target="_blank" rel="noopener">什么是合法的 Go 代码及其原因</a>。</li>
<li><a href="https://golang.org/cmd/go/" target="_blank" rel="noopener">Go 语言工具及其文档</a>，也可以通过 <code>go help</code> 查看。有时会涉及到其他内容，你也可以查看<a href="https://golang.org/pkg/cmd/go/internal/help/" target="_blank" rel="noopener">这些不够精细的内容</a>。</li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">编写符合社区标准的代码</a>。</li>
<li><a href="https://golang.org/pkg/testing/#pkg-overview" target="_blank" rel="noopener">对代码进行测试</a>。</li>
<li><a href="https://godoc.org/" target="_blank" rel="noopener">寻找新的依赖包或查看公用包的文档</a>。</li>
</ul>
<p>除此以外还有许多有价值的文档可以作为补充，但这些应该已经足够让你有一个良好的开端了。作为一个 Go 语言的初学者，如果你发现本文有任何遗漏之处（我可能会补充更多的细节）或者你找到了任何有价值的参考资料，请<a href="https://twitter.com/TheMerovius" target="_blank" rel="noopener">通过 Twitter 联系我</a>。如果你已经是一个经验丰富的 Go 语言开发者，并且你发现我遗漏了某些重要的内容（但是我有意忽略了一些重要的参考资料，使得初学者们可以感受到 Go 语言学习中的新鲜感:smile:），也请给我留言。</p>
<hr>
<p>[1]<a name="note1"></a> 注：Go 开发团队目前正在对<strong>模块</strong>做一些支持，模块是包之上的代码分发单元，这些支持包括版本控制和一些可以使“传统” Go 语言工具解决问题的基础工作。等这些支持完成以后，这一段中的所有内容基本上就都过时了。对模块的支持<strong>目前</strong>是有的，但还不是 Go 语言的一部分。由于本文的核心内容是对 Go 语言的不同组成部分进行简要介绍，这些内容是不太容易发生变化的，<strong>目前来看</strong>我认为理解这些历史问题也是很有必要的。</p>
<blockquote>
<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p>
</blockquote>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019-05-16-what-we-ve-learned-about-hiring-engineering-managers/" itemprop="url">【译】我们从招聘技术经理的过程中学到了什么</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-05-16T05:32:55.000Z" itemprop="datePublished">5月 16 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            19 分钟 读完 (约 2848 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<ul>
<li>原文地址：<a href="https://circleci.com/blog/what-we-ve-learned-about-hiring-engineering-managers/?utm_source=cooperpress&utm_medium=newsletter&utm_campaign=feb19&utm_content=javascript-weekly" target="_blank" rel="noopener">What we’ve learned about hiring engineering managers</a></li>
<li>原文作者：<a href="https://twitter.com/lrnrd" target="_blank" rel="noopener">Lena Reinhard</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/what-we-ve-learned-about-hiring-engineering-managers.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/what-we-ve-learned-about-hiring-engineering-managers.md</a></li>
<li>译者：<a href="https://github.com/JackEggie" target="_blank" rel="noopener">JackEggie</a></li>
<li>校对者：<a href="https://github.com/portandbridge" target="_blank" rel="noopener">portandbridge</a>, <a href="https://github.com/Baddyo" target="_blank" rel="noopener">Baddyo</a></li>
</ul>
</blockquote>
<h1 id="我们从招聘技术经理的过程中学到了什么"><a href="#我们从招聘技术经理的过程中学到了什么" class="headerlink" title="我们从招聘技术经理的过程中学到了什么"></a>我们从招聘技术经理的过程中学到了什么</h1><p><img src="https://circleci.com/blog/media/EngineeringManagers.png" alt=""></p>
<p>在过去的一年里，我们对于理解负责 CircleCI 的技术经理所需的优秀品质有了重要的转变，并从中了解到我们作为一个组织的需求和价值观。我们大幅改变了招聘流程，通过这些努力，我们聘用了一些出色的人才，使我们技术管理团队的人数翻了一番。现在，我们想和大家分享这些经验。</p>
<h3 id="用与招聘工程师类似的方法招聘技术经理"><a href="#用与招聘工程师类似的方法招聘技术经理" class="headerlink" title="用与招聘工程师类似的方法招聘技术经理"></a>用与招聘工程师类似的方法招聘技术经理</h3><p>去年，我们分享了“<a href="https://circleci.com/blog/how-we-interview-engineers-at-circleci/" target="_blank" rel="noopener">我们是如何面试工程师的</a>”。这是我们当时同时用在工程师和技术经理身上的流程。在整个 2018 年中，有数百名候选人通过了我们的技术招聘流程。我们的工程师招聘流程如下：</p>
<p><img src="https://circleci.com/blog/media/HiringProcessBefore1.png" alt="之前的招聘流程"></p>
<p><strong>申请人简历审查 &gt; 招聘经理电话筛选 &gt; 编码风格评估 &gt; 整体能力评估 &gt; 最后一轮面试（考察团队协作、CTO 谈话、产品面试）。有关此流程的更多细节，请参见<a href="https://circleci.com/blog/how-we-interview-engineers-at-circleci/" target="_blank" rel="noopener">博客文章</a>。</strong></p>
<p>在 2018 年初，我们对工程师和技术经理采用了相同的招聘流程。当时，我们招聘技术经理时重点关注的是候选人的技术背景与团队的技术工作是否匹配。正如我们在之前的文章中所写的那样，“我们把一个编程问题加了进来，因为我们需要了解一项非常重要的东西 —— 候选人的价值观和优势是否与他们将要管理的团队保持一致。”我们对几个应聘技术经理的候选人采用了该招聘流程，发现大部分情况下都会到现场面试阶段，但在现场考察的过程中，我们发现他们的管理技能与我们所期望的不匹配 —— 而发现这一点的时候已经太晚了。</p>
<p>这让我们看到了一个更大的问题：它让我们意识到，我们试图统一招聘流程的做法，让我们把关注点和优化方向放在了错误的技能上。曾经有一段时间，我们认为技术经理精通技术是一件好事。我们当时打算采用 <a href="https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf" target="_blank" rel="noopener">Spotify 模式</a>，这能让不同部门的交付团队和经理通过某种规定来达成一致。随着我们在使用该组织模型的过程中对其的不断改进，也为了适应我们作为一个分散式技术组织的需求，我们意识到我们必须要更多地分散领导权。</p>
<p>我们引入了额外的角色来支持我们团队的不同职责：团队领导，负责其所在团队的交付；技术领导，负责推进技术工作。我们还将所有工程师对各级领导的期望编成新的<a href="https://circleci.com/blog/why-we-re-designed-our-engineering-career-paths-at-circleci/" target="_blank" rel="noopener">技术能力模型</a>。我们见证了这些改进的成效，这也鼓励我们继续深入理解一名好的技术经理需要哪些品质。</p>
<h3 id="更好地支持工程师"><a href="#更好地支持工程师" class="headerlink" title="更好地支持工程师"></a>更好地支持工程师</h3><p>管理与技术大不相同。我们需要把技术管理工作与普通的管理工作区别开，它们需要不同的工作技能。CircleCI 的技术经理现在致力于人员的管理中：关注工程师、技术负责人、团队负责人的职业发展。他们会与其下属工程师们进行定期的一对一职业发展谈话，并负责他们的目标设定、反馈和职业生涯指导。他们还会跨团队交流，以保证团队的健康、知识共享、践行公司的价值观和各个团队间目标的一致性。这意味着我们工程师的经理对其下属的职业发展有着很大的兴趣和投入，团队中也会有专人指导他们完成产品交付过程。</p>
<h3 id="使我们的流程适用于我们新的价值观"><a href="#使我们的流程适用于我们新的价值观" class="headerlink" title="使我们的流程适用于我们新的价值观"></a>使我们的流程适用于我们新的价值观</h3><p>在我们了解了技术管理中真正重要的能力之后，我们针对人员管理能力和能否践行公司的价值观调整了应聘职位。我们还改变了招聘流程和每个面试阶段的内容，以便在面试过程中及早确定应聘者在以上领域的能力。同时，我们为所有的应聘者调整了面试流程，现在的面试流程结构性更强、更注重面试时的行为了。</p>
<p>这是我们现在招聘技术经理的流程：</p>
<p><img src="https://circleci.com/blog/media/HiringProcessAfter1.png" alt="调整之后的技术经理招聘流程"></p>
<p><strong>申请人简历审查 &gt; 招聘经理电话筛选 &gt; 面对面解题 &gt; 产品思维和工作拆分能力研讨 &gt; 最后一轮面试（技术团队成员面试、管理技能挖掘、产品面试）。</strong> <strong>注：我们一直在寻找改进该流程的方式，所以这些阶段可能会变化</strong></p>
<p>新的流程强调人员管理和践行公司的价值观，我们通过下面的步骤来评估这些能力：</p>
<ol>
<li><strong>招聘经理电话筛选：</strong> 该职位的招聘经理会和应聘者谈论他们在不同领域的管理经验。</li>
<li><strong>考察团队协作：</strong> 这是一轮协作面试，应聘者会与我们的一名技术经理搭档。他们会一起想办法，解决我们团队以前所面临的两个难题，这两个问题仍然可能再次出现。就像我们的技术结对考察一样，我们希望面试能反映出我们正在做的工作 —— 作为一个技术管理团队，一起讨论问题和寻找解决方案在我们的日常工作中是非常重要的。这个阶段的面试帮助我们更多地了解应聘者会如何应对团队的问题，以及他们是如何与同事合作的。</li>
<li><strong>产品思维和工作拆分能力评估：</strong> 在这一轮面试中，应聘者会和我们的技术管理团队的另一名成员讨论一些工作和交付的能力相关的问题，从客户价值的角度来讨论该问题。</li>
<li><strong>技术团队成员面试：</strong> 应聘者会与他将要共事的一名高级工程师谈话。他们也会一起探讨团队在过去所面临的协作问题。我们希望应聘者的能力足以在了解自身局限性的情况下仍能指导、帮助并参与技术团队的工作讨论，也能在尽量避免直接做决策情况下支持技术团队作出自己的决策。</li>
<li><strong>管理技能挖掘：</strong> 这一阶段的谈话通常是与技术管理团队的高级成员进行的，会深入讨论领导技能和应聘者的管理经验。</li>
<li><strong>产品面试：</strong> 最后一轮面试是与一名产品团队的成员进行的，重点考察应聘者对产品、流程和构建健康的技术团队的看法。</li>
</ol>
<h3 id="下一阶段的计划"><a href="#下一阶段的计划" class="headerlink" title="下一阶段的计划"></a>下一阶段的计划</h3><p>以这种方式改变我们的流程有助于我们筛选应聘者的正确价值观和技能，并能及早确定哪些候选人符合这些价值观和技能。最后，它能使我们能够雇佣到优秀的管理者，他们关心整个团队，他们的价值观与团队的价值观相一致，他们能够帮助、带领我们的技术团队进入下一个成长阶段。</p>
<p>目前，我们正在努力使该流程与我们新采用的技术管理能力模型保持完全一致（该模型还没有公布，但是我们很快就会把它共享出来）。</p>
<p>如果你对我们的价值观和技术经理职位感兴趣，请联系我们 —— <a href="https://boards.greenhouse.io/circleci/jobs/4195911002" target="_blank" rel="noopener">欧洲技术经理</a>和<a href="https://boards.greenhouse.io/circleci/jobs/4200209002" target="_blank" rel="noopener">北美技术经理</a>热招中！如果你希望与一个优秀的团队和一位对你的成长有帮助的经理共事感兴趣，欢迎<a href="https://boards.greenhouse.io/circleci" target="_blank" rel="noopener">以工程师的身份</a>加入我们！</p>
<p>欢迎评论我们的招聘流程，如果你对此有任何反馈，请发送 Email 至：<a href="mailto:lena@circleci.com" target="_blank" rel="noopener">lena@circleci.com</a></p>
<p>扩展阅读：</p>
<ul>
<li><a href="https://circleci.com/blog/why-we-re-designed-our-engineering-career-paths-at-circleci/" target="_blank" rel="noopener">为什么我们要在 CircleCI 重新做职业规划</a></li>
<li><a href="https://circleci.com/blog/interviewing-as-an-outsider-how-i-finally-got-seen-in-tech/" target="_blank" rel="noopener">以局外人的身份进行面试：我最终如何在科技界崭露头角</a></li>
<li><a href="https://circleci.com/blog/onboarding-onto-a-distributed-team/" target="_blank" rel="noopener">加入分散式团队：主动提问</a></li>
</ul>
<blockquote>
<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p>
</blockquote>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019-05-04-distributed-transactions-in-spring-with-and-without-xa-part-1/" itemprop="url">【译】Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-05-04T02:24:09.000Z" itemprop="datePublished">5月 4 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            26 分钟 读完 (约 3825 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<ul>
<li>原文地址：<a href="https://www.javaworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html" target="_blank" rel="noopener">Distributed transactions in Spring, with and without XA - Part I</a></li>
<li>原文作者：<a href="mailto:david.syer@springsource.com" target="_blank" rel="noopener">David Syer</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-1.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-1.md</a></li>
<li>译者：<a href="https://github.com/JackEggie" target="_blank" rel="noopener">JackEggie</a></li>
<li>校对者：<a href="https://github.com/fireairforce" target="_blank" rel="noopener">fireairforce</a></li>
</ul>
</blockquote>
<h1 id="Spring-的分布式事务实现-—-使用和不使用-XA-—-第一部分"><a href="#Spring-的分布式事务实现-—-使用和不使用-XA-—-第一部分" class="headerlink" title="Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分"></a>Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分</h1><blockquote>
<ul>
<li><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-1.md" target="_blank" rel="noopener">Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分</a></li>
<li><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-2.md" target="_blank" rel="noopener">Spring 的分布式事务实现 — 使用和不使用 XA — 第二部分</a></li>
<li><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-3.md" target="_blank" rel="noopener">Spring 的分布式事务实现 — 使用和不使用 XA — 第三部分</a></li>
</ul>
</blockquote>
<blockquote>
<p>Spring 的 7 种事务处理模式</p>
</blockquote>
<p>虽然在 Spring 中分布式事务通常使用 Java Transaction API 和 XA 协议实现，但也有其他的实现方式。最好的实现方式取决于应用程序所使用资源的类型，以及你是否愿意在性能、安全性、可靠性和数据完整性之间做出权衡。针对这个 Java 中的典型问题，Spring 的开发者 David Syer 将会介绍 7 种 Spring 分布式应用的实现方式，其中 3 种实现使用了 XA 协议，另外 4 种使用了其他的实现方式。（中级知识点）</p>
<p>Spring 框架对 Java Transaction API (JTA) 的支持使应用程序能够<a href="http://www.javaworld.com/javaworld/jw-04-2007/jw-04-xa.html" target="_blank" rel="noopener">无需在 Java EE 容器中</a>即可使用分布式事务和 XA 协议。然而，即使有了这种支持，XA 的性能开销仍然很大，而且可能不可靠并且难于管理。不过令人惊喜的是，某种特定类型的应用程序可以完全避免使用 XA 来实现分布式事务。</p>
<p>为了让你对分布式事务的各种实现方式有充分的理解和思考，我将详细分析这 7 种事务处理模式，并提供代码示例帮助你理解得更具体。我将根据安全性和可靠性来依次介绍这些模式，从通常来说数据完整性和原子性程度最高的模式开始。当你按顺序浏览时，你会看到越来越多的警示说明和限制条件。这些模式的性能开销也大致相反（从开销最大的模式开始）。与编写业务代码完全不同的是，这些模式都是从架构复杂度和技术难度考虑的，所以我不会关心业务用例，只关心使每种模式正常工作的最小代码量。</p>
<p>注意，只有前三种模式涉及 XA。而从性能的角度考虑，这些模式可能无法使用或性能差到不可接受。我不会像介绍其他模式那样对 XA 模式有详细的讨论，因为 XA 在其他地方已经有很多介绍了，不过我提供了第一个模式（基于 XA）的简单示例。通过阅读本文，你将了解使用分布式事务可以做什么、不能做什么，何时使用 XA、何时不使用 XA，以及如何避免使用 XA。</p>
<h2 id="分布式事务及其原子性"><a href="#分布式事务及其原子性" class="headerlink" title="分布式事务及其原子性"></a>分布式事务及其原子性</h2><p>一个<strong>分布式事务</strong>通常包含多个事务资源。事务资源是指关系型数据库和消息中间件的连接。一个典型的事务资源都会有像 <code>begin()</code>、<code>rollback()</code>、<code>commit()</code> 这样的 API。在 Java 中，一个事务资源通常表现为底层连接工厂提供的实例：对于数据库来说，就是 <code>Connection</code> 对象（由 <code>DataSource</code> 提供）或是 <a href="http://www.javaworld.com/javaworld/jw-01-2008/jw-01-jpa1.html" target="_blank" rel="noopener">Java Persistence API</a>（JPA）的 <code>EntityManager</code> 对象；对于 <a href="http://www.javaworld.com/jw-01-1999/jw-01-jms.html" target="_blank" rel="noopener">Java Message Service</a>（JMS）来说，则是 <code>Session</code> 对象。</p>
<p>在一个典型的例子中，一个 JMS 消息触发了数据库的更新。根据时间先后顺序，一次成功的交互过程如下：</p>
<ol>
<li>启动消息事务</li>
<li><strong>接收消息</strong></li>
<li>启动数据库事务</li>
<li><strong>更新数据库</strong></li>
<li>提交数据库事务</li>
<li>提交消息事务</li>
</ol>
<p>如果数据库在更新数据时报错（如约束冲突），理想的交互顺序如下：</p>
<ol>
<li>启动消息事务</li>
<li><strong>接收消息</strong></li>
<li>启动数据库事务</li>
<li><strong>更新数据库失败！</strong></li>
<li>回滚数据库事务</li>
<li>回滚消息事务</li>
</ol>
<p>在这个例子中，消息在最后回滚完成之后回到了中间件，在某个时刻将再次提交到另一个事务中。这通常是一件好事，因为如果这样做的话更新数据时发生的错误将会被记录下来。（自动重试和异常处理的机制超出了本文的讨论范围。）</p>
<p>上述两个例子中最重要的特点就是<strong>原子性</strong>，逻辑上来说，一个事务要么完全成功，要么完全失败。</p>
<p>那么是什么保证了上面两个例子在流程上的一致性呢？我们必须在事务资源之间进行一些同步，以便在一个事务提交之后，另一个事务才能提交。否则，整个事务就不是原子性的。因为涉及多个资源，所以事务是分布式的。如果不进行同步，事务就不会是原子性的。分布式事务的理论和实现上的困难都与资源的同步（或缺少资源）有关。</p>
<p>下面讨论的前三个模式都是基于 XA 协议的。由于这些模式已经被普及，所以在这里我不会介绍得很详细。如果你对 XA 的模式非常熟悉，你可以直接跳到<a href="#共享事务资源模式">共享事务资源模式</a>。</p>
<h2 id="完整的-XA-协议与两阶段提交（2PC）"><a href="#完整的-XA-协议与两阶段提交（2PC）" class="headerlink" title="完整的 XA 协议与两阶段提交（2PC）"></a>完整的 XA 协议与两阶段提交（2PC）</h2><p>如果你需要确保应用程序的事务在服务器宕机（服务器崩溃或断电）之后仍能够恢复，那么完整的 XA 协议是你唯一的选择。在下面的例子中，用于同步事务的共享资源是一个特殊的事务管理器，它使用 XA 协议协调了进程的信息。在 Java 中，从开发者的角度来看，该协议是通过 JTA 的 <code>UserTransaction</code> 对象暴露出来的。</p>
<p>作为一个系统接口，XA 是大多数开发者从未见过的一种底层技术。开发者需要知道 XA 协议的存在、它能做什么、性能消耗如何，以及它是如何操作事务资源的。性能消耗来自于<a href="http://www.javaworld.com/jw-07-2000/jw-0714-transaction.html" target="_blank" rel="noopener">两阶段提交</a>（2PC）协议，事务管理器使用该协议来确保所有资源能在事务结束前就事务的结果达成一致。</p>
<p>如果应用程序是基于 Spring 构建的，它将使用 Spring 中的 <code>JtaTransactionManager</code> 和 Spring 声明性事务管理来隐藏底层同步的细节。对于开发者来说，使用 XA 与否取决于工厂资源的配置方式：在应用程序中如何配置 <code>DataSource</code> 实例和事务管理器。本文包含了一个示例应用程序（<code>atomikos-db</code> 项目），它演示了这种配置方式。该应用程序中只有 <code>DataSource</code> 实例和事务管理器是基于 XA 或者 JTA 的。</p>
<p>要查看示例的运行方式，请运行 <code>com.springsource.open.db</code> 下的单元测试。<code>MulipleDataSourceTests</code> 类向两个数据源插入了数据，然后使用 Spring 的集成支持特性将事务回滚，如清单 1 所示：</p>
<h4 id="清单-1-事务回滚"><a href="#清单-1-事务回滚" class="headerlink" title="清单 1. 事务回滚"></a>清单 1. 事务回滚</h4><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line">  <span class="hljs-meta">@Test</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsertIntoTwoDataSources</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> count = getJdbcTemplate().update(</span><br><span class="line">        <span class="hljs-string">"INSERT into T_FOOS (id,name,foo_date) values (?,?,null)"</span>, <span class="hljs-number">0</span>,</span><br><span class="line">        <span class="hljs-string">"foo"</span>);</span><br><span class="line">    assertEquals(<span class="hljs-number">1</span>, count);</span><br><span class="line"></span><br><span class="line">    count = getOtherJdbcTemplate()</span><br><span class="line">        .update(</span><br><span class="line">            <span class="hljs-string">"INSERT into T_AUDITS (id,operation,name,audit_date) values (?,?,?,?)"</span>,</span><br><span class="line">            <span class="hljs-number">0</span>, <span class="hljs-string">"INSERT"</span>, <span class="hljs-string">"foo"</span>, <span class="hljs-keyword">new</span> Date());</span><br><span class="line">    assertEquals(<span class="hljs-number">1</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 数据的变更将在此方法退出后回滚</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后 <code>MulipleDataSourceTests</code> 将会验证这两个操作都回滚完成，如清单 2 所示：</p>
<h4 id="清单-2-验证回滚"><a href="#清单-2-验证回滚" class="headerlink" title="清单 2. 验证回滚"></a>清单 2. 验证回滚</h4><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@AfterTransaction</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkPostConditions</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> count = getJdbcTemplate().queryForInt(<span class="hljs-string">"select count(*) from T_FOOS"</span>);</span><br><span class="line">    <span class="hljs-comment">// 该数据变更已被测试框架回滚</span></span><br><span class="line">    assertEquals(<span class="hljs-number">0</span>, count);</span><br><span class="line"></span><br><span class="line">    count = getOtherJdbcTemplate().queryForInt(<span class="hljs-string">"select count(*) from T_AUDITS"</span>);</span><br><span class="line">    <span class="hljs-comment">// 由于 XA 的存在，该数据变更也被回滚了</span></span><br><span class="line">    assertEquals(<span class="hljs-number">0</span>, count);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>为了更好地理解 Spring 事务管理的工作原理以及配置的方式，请参阅 <a href="http://static.springframework.org/spring/docs/2.5.x/reference/new-in-2.html#new-in-2-middle-tier" target="_blank" rel="noopener">Spring 参考文档</a>。</p>
<h2 id="XA-与-1PC-优化"><a href="#XA-与-1PC-优化" class="headerlink" title="XA 与 1PC 优化"></a>XA 与 1PC 优化</h2><p>这种模式通过避免 2PC 的性能开销对许多只包含单资源事务的事务管理器进行了优化。你将会希望你的应用程序服务能够借此解决这个问题。</p>
<h2 id="XA-与最终资源策略"><a href="#XA-与最终资源策略" class="headerlink" title="XA 与最终资源策略"></a>XA 与最终资源策略</h2><p>XA 事务管理器的另一个特性是，当除某一个资源外的所有资源都支持 XA 时，它仍然可以提供与所有资源都支持 XA 时相同的数据恢复保证。通过对资源进行排序，并使非 XA 资源参与决策来实现该特性。如果提交失败，则回滚所有其他资源。这几乎是 100% 的完全性保证，但还不够完美。当提交失败时，除非采取额外的措施（在一些高端实现中有这样的实现），否则报错的跟踪信息会很少。</p>
<h2 id="共享事务资源模式"><a href="#共享事务资源模式" class="headerlink" title="共享事务资源模式"></a>共享事务资源模式</h2><p>在某些系统中，为了降低复杂性和增加吞吐量，一种较好的模式是通过确保系统中的所有事务资源实际上都是同一个资源的不同形式，从而完全消除对 XA 的依赖。显然，这在所有的用例中都是不可能的，但这种模式与 XA 一样可靠，而且通常要快得多。这样的共享事务资源模式是足够可靠的，但只限于某些特定的平台和处理场景。</p>
<p>有一个这种模式的简单例子对很多人来说都很熟悉，即在对象关系映射（ORM）组件和 <a href="http://www.javaworld.com/javaworld/jw-05-2006/jw-0501-jdbc.html" target="_blank" rel="noopener">JDBC</a> 组件之间共享数据库的 <code>Connection</code>。这就是你使用支持 ORM 工具的 Spring 事务管理器时所发生的事情，如 <a href="http://www.javaworld.com/javaworld/jw-10-2004/jw-1018-hibernate.html" target="_blank" rel="noopener">Hibernate</a>、<a href="http://www.eclipse.org/eclipselink/" target="_blank" rel="noopener">EclipseLink</a> 和 <a href="http://www.javaworld.com/javaworld/jw-01-2008/jw-01-jpa1.html" target="_blank" rel="noopener">Java Persistence API</a>（JPA）。同一个事务可以安全地跨 ORM 和 JDBC 组件使用，该执行过程通常由控制事务的服务级方法来实现。</p>
<p>该模式的另一个有效用法是单个数据库的消息驱动更新（如本文中介绍的简单例子所示）。消息中间件系统需要将数据存储在某个地方，通常是关系数据库中。要实现此模式，只需指定消息传递系统的目标数据库为同一个业务数据库即可。此模式需要消息中间件的供应商公开其存储策略的详细信息，以便可以将其配置指向相同的数据库并挂接到相同的事务中。</p>
<p>并不是所有的供应商都能做到这一点。另一种适用于几乎所有数据库的方式，是使用 <a href="http://activemq.apache.org/" target="_blank" rel="noopener">Apache ActiveMQ</a> 进行消息传递并将存储策略配置到消息代理服务器中。了解其中的技巧，配置起来就会非常简单。本文的 <code>shared-jms-db</code> 示例项目展示了这种配置方式。应用程序的代码中（在本例中是单元测试）不需要感知这种模式的使用，因为它已经在 Spring 配置中已经以声明方式被启用了。</p>
<p>示例中名为 <code>SynchronousMessageTriggerAndRollbackTests</code> 的单元测试验证了所有同步消息的接收处理。<code>testReceiveMessageUpdateDatabase</code> 方法接收了两条消息，并将这两条消息中的数据记录插入到数据库中。当退出该方法时，测试框架将会回滚当前的事务，接下来你就可以验证消息和数据库更新都已经回滚，如清单 3 所示：</p>
<h4 id="清单-3-验证消息和数据库更新的回滚"><a href="#清单-3-验证消息和数据库更新的回滚" class="headerlink" title="清单 3. 验证消息和数据库更新的回滚"></a>清单 3. 验证消息和数据库更新的回滚</h4><p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@AfterTransaction</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkPostConditions</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  assertEquals(<span class="hljs-number">0</span>, SimpleJdbcTestUtils.countRowsInTable(jdbcTemplate, <span class="hljs-string">"T_FOOS"</span>));</span><br><span class="line">  List&lt;String&gt; list = getMessages();</span><br><span class="line">  assertEquals(<span class="hljs-number">2</span>, list.size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该配置最重要的特性是 ActiveMQ 的持久化策略，它将业务数据源的消息系统连接到同一个 <code>DataSource</code>，用于接收消息的 Spring <code>JmsTemplate</code> 上的标志位也同样重要。配置 ActiveMQ 持久化策略的方式如清单 4 所示：</p>
<h4 id="清单-4-ActiveMQ-的持久化配置"><a href="#清单-4-ActiveMQ-的持久化配置" class="headerlink" title="清单 4. ActiveMQ 的持久化配置"></a>清单 4. ActiveMQ 的持久化配置</h4><p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"connectionFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.activemq.ActiveMQConnectionFactory"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">depends-on</span>=<span class="hljs-string">"brokerService"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">vm:</span>//<span class="hljs-attr">localhost</span>?<span class="hljs-attr">async</span>=<span class="hljs-string">false</span>" /&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"brokerService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.activemq.broker.BrokerService"</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">"start"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"stop"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> &gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.activemq.store.jdbc.JDBCPersistenceAdapter"</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> &gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.springsource.open.jms.JmsTransactionAwareDataSourceProxy"</span>&gt;</span></span><br><span class="line">          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> /&gt;</span></span><br><span class="line">          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> /&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>用于接收消息的 Spring <code>JmsTemplate</code> 上的标志位配置如清单 5 所示：</p>
<h4 id="清单-5-为事务配置-JmsTemplate"><a href="#清单-5-为事务配置-JmsTemplate" class="headerlink" title="清单 5. 为事务配置 JmsTemplate"></a>清单 5. 为事务配置 <code>JmsTemplate</code></h4><p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jmsTemplate"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="hljs-comment">&lt;!-- 这很重要... --&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>  /&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有设置 <code>sessionTransacted=true</code>，就永远不会执行 JMS 会话事务的 API 调用，并且消息的接收将无法回滚。这里重要的一点是嵌入式消息代理服务器中的特殊参数 <code>async=false</code> 和对 <code>DataSource</code> 的包装，他们共同确保了 ActiveMQ 和 Spring 共同使用了同一个 JDBC 事务的 <code>Connection</code>。</p>
<blockquote>
<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p>
</blockquote>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019-04-14-your-first-cli-tool-with-rust/" itemprop="url">【译】用 Rust 打造你的第一个命令行工具</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-04-14T02:40:13.000Z" itemprop="datePublished">4月 14 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            31 分钟 读完 (约 4666 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<ul>
<li>原文地址：<a href="https://www.demainilpleut.fr/your-first-cli-tool-with-rust/" target="_blank" rel="noopener">Your first CLI tool with Rust</a></li>
<li>原文作者：<a href="https://www.demainilpleut.fr/authors/jveillet" target="_blank" rel="noopener">Jérémie Veillet</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/your-first-cli-tool-with-rust.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/your-first-cli-tool-with-rust.md</a></li>
<li>译者：<a href="https://github.com/JackEggie" target="_blank" rel="noopener">JackEggie</a></li>
<li>校对者：<a href="https://github.com/TloveYing" target="_blank" rel="noopener">TloveYing</a></li>
</ul>
</blockquote>
<h1 id="用-Rust-打造你的第一个命令行工具"><a href="#用-Rust-打造你的第一个命令行工具" class="headerlink" title="用 Rust 打造你的第一个命令行工具"></a>用 Rust 打造你的第一个命令行工具</h1><p>在精彩的编程世界里，你可能听说过这种名为 Rust 的新语言。它是一种开源的系统级编程语言。它专注于性能、内存安全和并行性。你可以像 C/C++ 那样用它编写底层应用程序。</p>
<p>你可能已经在 <a href="https://webassembly.org/" target="_blank" rel="noopener">Web Assembly</a> 网站上见到过它了。Rust 能够编译 WASM 应用程序，你可以在 <a href="https://webassembly.org/docs/use-cases/" target="_blank" rel="noopener">Web Assembly FAQ</a> 上找到很多例子。它也被认为是 <a href="https://servo.org/" target="_blank" rel="noopener">servo</a> 的基石，servo 是一个在 Firefox 中实现的高性能浏览器引擎。</p>
<p>这可能会让你望而却步，但这不是我们要在这里讨论的内容。我们将介绍如何使用它构建命令行工具，而你可能会从中发现很多有意思的东西。</p>
<h2 id="为什么是-Rust？"><a href="#为什么是-Rust？" class="headerlink" title="为什么是 Rust？"></a>为什么是 Rust？</h2><p>好吧，让我把事情说清楚。我本可以用任何其他语言或框架来完成命令行工具。我可以选 C、Go、Ruby 等等。甚至，我可以使用经典的 bash。</p>
<p>在 2018 年中，我想学习一些新东西，Rust 激发了我的好奇心，同时我也需要构建一些简单的小工具来自动化工作和个人项目中的一些流程。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>你可以使用 <a href="https://rustup.rs/" target="_blank" rel="noopener">Rustup</a> 来设置你的开发环境，它是安装和配置你机器上所有的 Rust 工具的主要入口。</p>
<p>如果你在 Linux 和 MacOS 上工作，使用如下命令即可完成安装：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl &lt;https://sh.rustup.rs&gt; -sSf | sh</span><br></pre></td></tr></table></figure></p>
<p>如果你使用的是 Windows 系统，同样地，你需要在 <a href="https://rustup.rs/" target="_blank" rel="noopener">Rustup 网站</a>上下载一个 <code>exe</code> 并运行。</p>
<p>如果你用的是 Windows 10，我建议你使用 <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">WSL</a> 来完成安装。以上就是安装所需的步骤，我们现在可以去创建我们的第一个 Rust 应用程序了！</p>
<h2 id="你的第一个-Rust-应用程序"><a href="#你的第一个-Rust-应用程序" class="headerlink" title="你的第一个 Rust 应用程序"></a>你的第一个 Rust 应用程序</h2><p>我们在这里要做的是，仿照 <a href="https://en.wikipedia.org/wiki/Cat_(Unix)" target="_blank" rel="noopener">cat</a> 来构建一个 UNIX 实用工具，或者至少是一个简化版本，我们称之为 <code>kt</code>。这个应用程序将接受一个文件路径作为输入，并在终端的标准输出中显示文件的内容。</p>
<p>要创建这个应用程序的基本框架，我们将使用一个名为 <a href="https://github.com/rust-lang/cargo/" target="_blank" rel="noopener">Cargo</a> 的工具。它是 Rust 的包管理器，可以将它看作是 Rust 工具的 NPM（对于 Javascript 开发者）或 Bundler（对于 Ruby 开发者）。</p>
<p>打开你的终端，进入你想要存储源代码的路径下，然后输入下面的代码。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo init kt</span><br></pre></td></tr></table></figure></p>
<p>这将会创建一个名为 <code>kt</code> 的目录，该目录下已经有我们应用程序的基本结构了。</p>
<p>如果我们 <code>cd</code> 到该目录中，我们将看到这个目录结构。而且，方便的是，这个项目已经默认初始化了 git。真是太好了！</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="hljs-built_in">cd</span> kt/</span><br><span class="line">  |</span><br><span class="line">  .git/</span><br><span class="line">  |</span><br><span class="line">  .gitignore</span><br><span class="line">  |</span><br><span class="line">  Cargo.toml</span><br><span class="line">  |</span><br><span class="line">  src/</span><br></pre></td></tr></table></figure></p>
<p><code>Cargo.toml</code> 文件包含了我们的应用程序的基本信息和依赖信息。同样地，可以把它看做应用程序的 <code>package.json</code> 或者 <code>Gemfile</code> 文件。</p>
<p><code>src/</code> 目录包含了应用程序的源文件，我们可以看到其中只有一个 <code>main.rs</code> 文件。检查文件的内容，我们可以看到其中只有一个 <code>main</code> 函数。</p>
<p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;</span><br><span class="line">    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>试试构建这个项目。由于没有外部依赖，它应该会构建得非常快。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line">Compiling kt v0.1.0 (/Users/jeremie/Development/kitty)</span><br><span class="line">Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 2.82s</span><br></pre></td></tr></table></figure></p>
<p>在开发模式下，你可以通过调用 <code>cargo run</code> 来执行二进制文件（用 <code>cargo run --- my_arg</code> 来传递命令行参数）。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.07s</span><br><span class="line">Running `target/debug/kt`</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p>
<p>恭喜你，你通过刚才的步骤已经创建并运行了你的第一个 Rust 应用程序了！🎉</p>
<h2 id="解析第一个命令行参数"><a href="#解析第一个命令行参数" class="headerlink" title="解析第一个命令行参数"></a>解析第一个命令行参数</h2><p>正如我之前在文章中所说的，我们正在尝试构建一个简化版的 <code>cat</code> 命令。我们的目标是模拟 <code>cat</code> 的行为，运行 <code>kt myfile.txt</code> 命令之后，在终端输出文件内容。</p>
<p>我们本来可以自己处理参数的解析过程，但幸运的是，一个 Rust 工具可以帮我们简化这个过程，它就是 <a href="https://github.com/clap-rs/clap" target="_blank" rel="noopener">Clap</a>。</p>
<p>这是一个高性能的命令行参数解析器，它让我们管理命令行参数变得很简单。</p>
<p>使用这个工具的第一步是打开 <code>Cargo.toml</code> 文件，并在其中添加指定的依赖项。如果你从未处理过 <code>.toml</code> 文件也没关系，它与 Windows 系统中的 <code>.INI</code> 文件极其相似。这种文件格式在 Rust 中是很常见的。</p>
<p>在这个文件中，你将看到有一些信息已经填充好了，比如作者、版本等等。我们只需要在 <code>[dependencies]</code> 下添加依赖项就行了。</p>
<p><figure class="highlight toml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[dependencies]</span></span><br><span class="line"><span class="hljs-attr">clap</span> = <span class="hljs-string">"~2.32"</span></span><br></pre></td></tr></table></figure></p>
<p>保存文件后，我们需要重新构建项目，以便能够使用依赖库。即使 <code>cargo</code> 下载了除 <code>clap</code> 以外的文件也不用担心，这是由于 <code>clap</code> 也有其所需的依赖关系。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line"> Updating crates.io index</span><br><span class="line">  Downloaded clap v2.32.0</span><br><span class="line">  Downloaded atty v0.2.11</span><br><span class="line">  Downloaded bitflags v1.0.4</span><br><span class="line">  Downloaded ansi_term v0.11.0</span><br><span class="line">  Downloaded vec_map v0.8.1</span><br><span class="line">  Downloaded textwrap v0.10.0</span><br><span class="line">  Downloaded libc v0.2.48</span><br><span class="line">  Downloaded unicode-width v0.1.5</span><br><span class="line">  Downloaded strsim v0.7.0</span><br><span class="line">   Compiling libc v0.2.48</span><br><span class="line">   Compiling unicode-width v0.1.5</span><br><span class="line">   Compiling strsim v0.7.0</span><br><span class="line">   Compiling bitflags v1.0.4</span><br><span class="line">   Compiling ansi_term v0.11.0</span><br><span class="line">   Compiling vec_map v0.8.1</span><br><span class="line">   Compiling textwrap v0.10.0</span><br><span class="line">   Compiling atty v0.2.11</span><br><span class="line">   Compiling clap v2.32.0</span><br><span class="line">   Compiling kt v0.1.0 (/home/jeremie/Development/kt)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 33.92s</span><br></pre></td></tr></table></figure></p>
<p>以上就是需要配置的内容，接下来我们可以动手，写一些代码来读取我们的第一个命令行参数。</p>
<p>打开 <code>main.rs</code> 文件。我们必须显式地声明我们要使用 Clap 库。</p>
<p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> clap;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">use</span> clap::&#123;Arg, App&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>extern crate</code> 关键字用于导入依赖库，你只需将其添加到主文件中，应用程序的任何源文件就都可以引用它了。<code>use</code> 部分则是指你将在这个文件中使用 <code>clap</code> 的哪个模块。</p>
<p>Rust 模块（module）的简要说明：</p>
<blockquote>
<p>Rust 有一个模块系统，能够以有组织的方式重用代码。模块是一个包含函数或类型定义的命名空间，你可以选择这些定义是否在其模块外部可见（public/private）。—— Rust 文档</p>
</blockquote>
<p>这里我们声明的是我们想要使用 <code>Arg</code> 和 <code>App</code> 模块。我们希望我们的应用程序有一个 <code>FILE</code> 参数，它将包含一个文件路径。Clap 可以帮助我们快速实现该功能。这里使用了一种链式调用方法的方式，这是一种令人非常愉悦的方式。</p>
<p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> matches = App::new(<span class="hljs-string">"kt"</span>)</span><br><span class="line">      .version(<span class="hljs-string">"0.1.0"</span>)</span><br><span class="line">      .author(<span class="hljs-string">"Jérémie Veillet. jeremie@example.com"</span>)</span><br><span class="line">      .about(<span class="hljs-string">"A drop in cat replacement written in Rust"</span>)</span><br><span class="line">      .arg(Arg::with_name(<span class="hljs-string">"FILE"</span>)</span><br><span class="line">            .help(<span class="hljs-string">"File to print."</span>)</span><br><span class="line">            .empty_values(<span class="hljs-literal">false</span>)</span><br><span class="line">        )</span><br><span class="line">      .get_matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次编译并执行，除了变量 <code>matches</code> 上的编译警告（对于 Ruby 开发者来说，可以在变量前面加上 <code>_</code>，它会告诉编译器该变量是可选的），它应该不会输出太多其他信息。</p>
<p>如果你向应用程序传递 <code>-h</code> 或者 <code>-V</code> 参数，程序会自动生成一个帮助信息和版本信息。我不知道你如何看待这个事情，但我觉得它 🔥🔥🔥。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- -h</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.03s</span><br><span class="line">     Running `target/debug/kt -h`</span><br><span class="line">kt 0.1.0</span><br><span class="line">Jérémie Veillet. jeremie@example.com</span><br><span class="line">A drop-in cat replacement written <span class="hljs-keyword">in</span> Rust</span><br><span class="line"></span><br><span class="line"> USAGE:</span><br><span class="line">    kt [FILE]</span><br><span class="line"></span><br><span class="line"> FLAGS:</span><br><span class="line">    -h, --<span class="hljs-built_in">help</span>       Prints <span class="hljs-built_in">help</span> information</span><br><span class="line">    -V, --version    Prints version information</span><br><span class="line"></span><br><span class="line"> ARGS:</span><br><span class="line">    &lt;FILE&gt;    File to <span class="hljs-built_in">print</span>.</span><br><span class="line"></span><br><span class="line">$ cargo run --- -V</span><br><span class="line">Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.04s</span><br><span class="line">Running target/debug/kt -V</span><br><span class="line">kt 0.1.0</span><br></pre></td></tr></table></figure></p>
<p>我们还可以尝试不带任何参数，启动程序，看看会发生什么。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run --</span><br><span class="line">Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.03s</span><br><span class="line">  Running `target/debug/kt`</span><br></pre></td></tr></table></figure></p>
<p>什么都没有发生。这是每次构建命令行工具时应该发生的默认行为。我认为不向应用程序传递任何参数就永远不应该触发任何操作。即使有时候这并不正确，但是在大多数情况下，永远不要执行用户从未打算执行的操作。</p>
<p>现在我们已经有了参数，我们可以深入研究如何<strong>捕获</strong>这个命令行参数并在标准输出中显示一些内容。</p>
<p>要实现这一点，我们可以使用 <code>clap</code> 中的 <code>value_of</code> 方法。请参考<a href="https://docs.rs/clap/2.32.0/clap/struct.ArgMatches.html#method.value_of" target="_blank" rel="noopener">文档</a>来了解该方法是怎么运作的。</p>
<p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> matches = App::new(<span class="hljs-string">"kt"</span>)</span><br><span class="line">      .version(<span class="hljs-string">"0.1.0"</span>)</span><br><span class="line">      .author(<span class="hljs-string">"Jérémie Veillet. jeremie@example.com"</span>)</span><br><span class="line">      .about(<span class="hljs-string">"A drop in cat replacement written in Rust"</span>)</span><br><span class="line">      .arg(Arg::with_name(<span class="hljs-string">"FILE"</span>)</span><br><span class="line">            .help(<span class="hljs-string">"File to print."</span>)</span><br><span class="line">            .empty_values(<span class="hljs-literal">false</span>)</span><br><span class="line">      )</span><br><span class="line">      .get_matches();</span><br><span class="line"></span><br><span class="line">     <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(file) = matches.value_of(<span class="hljs-string">"FILE"</span>) &#123;</span><br><span class="line">        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Value for file argument: &#123;&#125;"</span>, file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，你可以运行应用程序并传入一个随机字符串作为参数，在你的控制台中会回显该字符串。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- test.txt</span><br><span class="line">Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.02s</span><br><span class="line">  Running `target/debug/kt test.txt`</span><br><span class="line">Value <span class="hljs-keyword">for</span> file argument: test.txt</span><br></pre></td></tr></table></figure></p>
<p>请注意，目前我们实际上没有对该文件是否存在进行验证。那么我们应该怎么实现呢？</p>
<p>有一个标准库可以让我们检查一个文件或目录是否存在，使用方式非常简单。它就是 <code>std::path</code> 库。它有一个 <code>exists</code> 方法，可以帮我们检查文件是否存在。</p>
<p>如前所述，使用 <code>use</code> 关键字来添加依赖库，然后编写如下代码。你可以看到，我们使用 <code>If-Else</code> 条件控制在输出中打印一些文本。<code>println!</code> 方法会写入标准输出 <code>stdout</code>，而 <code>eprintln!</code> 会写入标准错误输出 <code>stderr</code>。</p>
<p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> clap;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">use</span> clap::&#123;Arg, App&#125;;</span><br><span class="line"><span class="hljs-keyword">use</span> std::path::Path;</span><br><span class="line"><span class="hljs-keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> matches = App::new(<span class="hljs-string">"kt"</span>)</span><br><span class="line">      .version(<span class="hljs-string">"0.1.0"</span>)</span><br><span class="line">      .author(<span class="hljs-string">"Jérémie Veillet. jeremie@example.com"</span>)</span><br><span class="line">      .about(<span class="hljs-string">"A drop in cat replacement written in Rust"</span>)</span><br><span class="line">      .arg(Arg::with_name(<span class="hljs-string">"FILE"</span>)</span><br><span class="line">            .help(<span class="hljs-string">"File to print."</span>)</span><br><span class="line">            .empty_values(<span class="hljs-literal">false</span>)</span><br><span class="line">        )</span><br><span class="line">      .get_matches();</span><br><span class="line"></span><br><span class="line">     <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(file) = matches.value_of(<span class="hljs-string">"FILE"</span>) &#123;</span><br><span class="line">        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Value for file argument: &#123;&#125;"</span>, file);</span><br><span class="line">        <span class="hljs-keyword">if</span> Path::new(&amp;file).exists() &#123;</span><br><span class="line">            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"File exist!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            eprintln!(<span class="hljs-string">"[kt Error] No such file or directory."</span>);</span><br><span class="line">            process::exit(<span class="hljs-number">1</span>); <span class="hljs-comment">// 程序错误终止时的标准退出码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们快要完成了！现在我们需要读取文件的内容并将结果显示在 <code>stdout</code> 中。</p>
<p>同样，我们将使用一个名为 <code>File</code> 的标准库来读取文件。我们将使用 <code>open</code> 方法读取文件的内容，然后将其写入一个字符串对象，该对象将在 <code>stdout</code> 中显示。</p>
<p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> clap;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">use</span> clap::&#123;Arg, App&#125;;</span><br><span class="line"><span class="hljs-keyword">use</span> std::path::Path;</span><br><span class="line"><span class="hljs-keyword">use</span> std::process;</span><br><span class="line"><span class="hljs-keyword">use</span> std::fs::File;</span><br><span class="line"><span class="hljs-keyword">use</span> std::io::&#123;Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> matches = App::new(<span class="hljs-string">"kt"</span>)</span><br><span class="line">      .version(<span class="hljs-string">"0.1.0"</span>)</span><br><span class="line">      .author(<span class="hljs-string">"Jérémie Veillet. jeremie@example.com"</span>)</span><br><span class="line">      .about(<span class="hljs-string">"A drop in cat replacement written in Rust"</span>)</span><br><span class="line">      .arg(Arg::with_name(<span class="hljs-string">"FILE"</span>)</span><br><span class="line">            .help(<span class="hljs-string">"File to print."</span>)</span><br><span class="line">            .empty_values(<span class="hljs-literal">false</span>)</span><br><span class="line">        )</span><br><span class="line">      .get_matches();</span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(file) = matches.value_of(<span class="hljs-string">"FILE"</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> Path::new(&amp;file).exists() &#123;</span><br><span class="line">           <span class="hljs-built_in">println!</span>(<span class="hljs-string">"File exist!!"</span>);</span><br><span class="line">           <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> f = File::open(file).expect(<span class="hljs-string">"[kt Error] File not found."</span>);</span><br><span class="line">           <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data = <span class="hljs-built_in">String</span>::new();</span><br><span class="line">           f.read_to_string(&amp;<span class="hljs-keyword">mut</span> data).expect(<span class="hljs-string">"[kt Error] Unable to read the  file."</span>);</span><br><span class="line">           <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;&#125;"</span>, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            eprintln!(<span class="hljs-string">"[kt Error] No such file or directory."</span>);</span><br><span class="line">            process::exit(<span class="hljs-number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次构建并运行此代码。恭喜你！我们现在有一个功能完整的工具了！🍾</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line">   Compiling kt v0.1.0 (/home/jeremie/Development/kt)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.70s</span><br><span class="line">$ cargo run -- ./src/main.rs</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.03s</span><br><span class="line">     Running `target/debug/kt ./src/main.rs`</span><br><span class="line">File exist!!</span><br><span class="line">extern crate clap;</span><br><span class="line"></span><br><span class="line">use clap::&#123;Arg, App&#125;;</span><br><span class="line">use std::path::Path;</span><br><span class="line">use std::process;</span><br><span class="line">use std::fs::File;</span><br><span class="line">use std::io::&#123;Read&#125;;</span><br><span class="line"></span><br><span class="line"> fn <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;</span><br><span class="line">    <span class="hljs-built_in">let</span> matches = App::new(<span class="hljs-string">"kt"</span>)</span><br><span class="line">      .version(<span class="hljs-string">"0.1.0"</span>)</span><br><span class="line">      .author(<span class="hljs-string">"Jérémie Veillet. jeremie@example.com"</span>)</span><br><span class="line">      .about(<span class="hljs-string">"A drop in cat replacement written in Rust"</span>)</span><br><span class="line">      .arg(Arg::with_name(<span class="hljs-string">"FILE"</span>)</span><br><span class="line">            .<span class="hljs-built_in">help</span>(<span class="hljs-string">"File to print."</span>)</span><br><span class="line">            .empty_values(<span class="hljs-literal">false</span>)</span><br><span class="line">        )</span><br><span class="line">      .get_matches();</span><br><span class="line"></span><br><span class="line">     <span class="hljs-keyword">if</span> <span class="hljs-built_in">let</span> Some(file) = matches.value_of(<span class="hljs-string">"FILE"</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> Path::new(&amp;file).<span class="hljs-function"><span class="hljs-title">exists</span></span>() &#123;</span><br><span class="line">            println!(<span class="hljs-string">"File exist!!"</span>);</span><br><span class="line">            <span class="hljs-built_in">let</span> mut f = File::open(file).expect(<span class="hljs-string">"[kt Error] File not found."</span>);</span><br><span class="line">            <span class="hljs-built_in">let</span> mut data = String::new();</span><br><span class="line">            f.read_to_string(&amp;mut data).expect(<span class="hljs-string">"[kt Error] Unable to read the  file."</span>);</span><br><span class="line">            println!(<span class="hljs-string">"&#123;&#125;"</span>, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            eprintln!(<span class="hljs-string">"[kt Error] No such file or directory."</span>);</span><br><span class="line">            process::<span class="hljs-built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="改进一点点"><a href="#改进一点点" class="headerlink" title="改进一点点"></a>改进一点点</h2><p>我们的应用程序现可以接收一个参数并在 <code>stdout</code> 中显示结果。</p>
<p>我们可以稍微调整一下整个打印阶段的性能，方法是用 <code>writeln!</code> 来代替 <code>println!</code>。这在 <a href="https://rust-lang-nursery.github.io/cli-wg/tutorial/output.html#a-note-on-printing-performance" target="_blank" rel="noopener">Rust 输出教程</a>中有很好的解释。在此过程中，我们可以清理一些代码，删除不必要的打印，并对可能的错误场景进行微调。</p>
<p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> clap;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">use</span> clap::&#123;Arg, App&#125;;</span><br><span class="line"><span class="hljs-keyword">use</span> std::path::Path;</span><br><span class="line"><span class="hljs-keyword">use</span> std::process;</span><br><span class="line"><span class="hljs-keyword">use</span> std::fs::File;</span><br><span class="line"><span class="hljs-keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> matches = App::new(<span class="hljs-string">"kt"</span>)</span><br><span class="line">      .version(<span class="hljs-string">"0.1.0"</span>)</span><br><span class="line">      .author(<span class="hljs-string">"Jérémie Veillet. jeremie@example.com"</span>)</span><br><span class="line">      .about(<span class="hljs-string">"A drop in cat replacement written in Rust"</span>)</span><br><span class="line">      .arg(Arg::with_name(<span class="hljs-string">"FILE"</span>)</span><br><span class="line">            .help(<span class="hljs-string">"File to print."</span>)</span><br><span class="line">            .empty_values(<span class="hljs-literal">false</span>)</span><br><span class="line">        )</span><br><span class="line">      .get_matches();</span><br><span class="line"></span><br><span class="line">     <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(file) = matches.value_of(<span class="hljs-string">"FILE"</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> Path::new(&amp;file).exists() &#123;</span><br><span class="line">            <span class="hljs-keyword">match</span> File::open(file) &#123;</span><br><span class="line">                <span class="hljs-literal">Ok</span>(<span class="hljs-keyword">mut</span> f) =&gt; &#123;</span><br><span class="line">                    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data = <span class="hljs-built_in">String</span>::new();</span><br><span class="line">                    f.read_to_string(&amp;<span class="hljs-keyword">mut</span> data).expect(<span class="hljs-string">"[kt Error] Unable to read the  file."</span>);</span><br><span class="line">                    <span class="hljs-keyword">let</span> stdout = std::io::stdout(); <span class="hljs-comment">// 获取全局 stdout 对象</span></span><br><span class="line">                    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> handle = std::io::BufWriter::new(stdout); <span class="hljs-comment">// 可选项：将 handle 包装在缓冲区中</span></span><br><span class="line">                    <span class="hljs-keyword">match</span> <span class="hljs-built_in">writeln!</span>(handle, <span class="hljs-string">"&#123;&#125;"</span>, data) &#123;</span><br><span class="line">                        <span class="hljs-literal">Ok</span>(_res) =&gt; &#123;&#125;,</span><br><span class="line">                        <span class="hljs-literal">Err</span>(err) =&gt; &#123;</span><br><span class="line">                            eprintln!(<span class="hljs-string">"[kt Error] Unable to display the file contents. &#123;:?&#125;"</span>, err);</span><br><span class="line">                            process::exit(<span class="hljs-number">1</span>);</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-literal">Err</span>(err) =&gt; &#123;</span><br><span class="line">                    eprintln!(<span class="hljs-string">"[kt Error] Unable to read the file. &#123;:?&#125;"</span>, err);</span><br><span class="line">                    process::exit(<span class="hljs-number">1</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            eprintln!(<span class="hljs-string">"[kt Error] No such file or directory."</span>);</span><br><span class="line">            process::exit(<span class="hljs-number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- ./src/main.rs</span><br><span class="line">  Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.02s</span><br><span class="line">    Running `target/debug/kt ./src/main.rs`</span><br><span class="line">extern crate clap;</span><br><span class="line"></span><br><span class="line">use clap::&#123;Arg, App&#125;;</span><br><span class="line">use std::path::Path;</span><br><span class="line">use std::process;</span><br><span class="line">use std::fs::File;</span><br><span class="line">use std::io::&#123;Read, Write&#125;;</span><br><span class="line"></span><br><span class="line"> fn <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;</span><br><span class="line">    <span class="hljs-built_in">let</span> matches = App::new(<span class="hljs-string">"kt"</span>)</span><br><span class="line">      .version(<span class="hljs-string">"0.1.0"</span>)</span><br><span class="line">      .author(<span class="hljs-string">"Jérémie Veillet. jeremie@example.com"</span>)</span><br><span class="line">      .about(<span class="hljs-string">"A drop in cat replacement written in Rust"</span>)</span><br><span class="line">      .arg(Arg::with_name(<span class="hljs-string">"FILE"</span>)</span><br><span class="line">            .<span class="hljs-built_in">help</span>(<span class="hljs-string">"File to print."</span>)</span><br><span class="line">            .empty_values(<span class="hljs-literal">false</span>)</span><br><span class="line">        )</span><br><span class="line">      .get_matches();</span><br><span class="line"></span><br><span class="line">     <span class="hljs-keyword">if</span> <span class="hljs-built_in">let</span> Some(file) = matches.value_of(<span class="hljs-string">"FILE"</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> Path::new(&amp;file).<span class="hljs-function"><span class="hljs-title">exists</span></span>() &#123;</span><br><span class="line">            match File::open(file) &#123;</span><br><span class="line">                Ok(mut f) =&gt; &#123;</span><br><span class="line">                    <span class="hljs-built_in">let</span> mut data = String::new();</span><br><span class="line">                    f.read_to_string(&amp;mut data).expect(<span class="hljs-string">"[kt Error] Unable to read the  file."</span>);</span><br><span class="line">                    <span class="hljs-built_in">let</span> stdout = std::io::stdout(); // 获取全局 stdout 对象</span><br><span class="line">                    <span class="hljs-built_in">let</span> mut handle = std::io::BufWriter::new(stdout); // 可选项：将 handle 包装在缓冲区中</span><br><span class="line">                    match writeln!(handle, <span class="hljs-string">"&#123;&#125;"</span>, data) &#123;</span><br><span class="line">                        Ok(_res) =&gt; &#123;&#125;,</span><br><span class="line">                        Err(err) =&gt; &#123;</span><br><span class="line">                            eprintln!(<span class="hljs-string">"[kt Error] Unable to display the file contents. &#123;:?&#125;"</span>, err);</span><br><span class="line">                            process::<span class="hljs-built_in">exit</span>(1);</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Err(err) =&gt; &#123;</span><br><span class="line">                    eprintln!(<span class="hljs-string">"[kt Error] Unable to read the file. &#123;:?&#125;"</span>, err);</span><br><span class="line">                    process::<span class="hljs-built_in">exit</span>(1);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            eprintln!(<span class="hljs-string">"[kt Error] No such file or directory."</span>);</span><br><span class="line">            process::<span class="hljs-built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们完成了！我们通过约 45 行代码就完成了我们的简化版 <code>cat</code> 命令 🤡，并且它表现得非常好！</p>
<h2 id="构建独立的应用程序"><a href="#构建独立的应用程序" class="headerlink" title="构建独立的应用程序"></a>构建独立的应用程序</h2><p>那么构建这个应用程序并将其安装到文件系统中要怎么做呢？向 cargo 寻求帮助吧！</p>
<p><code>cargo build</code> 接受一个 <code>---release</code> 标志位，以便我们可以指定我们想要的可执行文件的最终版本。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build --release</span><br><span class="line">   Compiling libc v0.2.48</span><br><span class="line">   Compiling unicode-width v0.1.5</span><br><span class="line">   Compiling ansi_term v0.11.0</span><br><span class="line">   Compiling bitflags v1.0.4</span><br><span class="line">   Compiling vec_map v0.8.1</span><br><span class="line">   Compiling strsim v0.7.0</span><br><span class="line">   Compiling textwrap v0.10.0</span><br><span class="line">   Compiling atty v0.2.11</span><br><span class="line">   Compiling clap v2.32.0</span><br><span class="line">   Compiling kt v0.1.0 (/home/jeremie/Development/kt)</span><br><span class="line">    Finished release [optimized] target(s) <span class="hljs-keyword">in</span> 28.17s</span><br></pre></td></tr></table></figure></p>
<p>生成的可执行文件位于该子目录中：<code>./target/release/kt</code>。</p>
<p>你可以将这个文件复制到你的 <code>PATH</code> 环境变量中，或者使用一个 cargo 命令来自动安装。应用程序将安装在 <code>~/.cargo/bin/</code> 目录中（确保该目录在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 的 <code>PATH</code> 环境变量中）。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo install --path .</span><br><span class="line">  Installing kt v0.1.0 (/home/jeremie/Development/kt)</span><br><span class="line">    Finished release [optimized] target(s) <span class="hljs-keyword">in</span> 0.03s</span><br><span class="line">  Installing /home/jeremie/.cargo/bin/kt</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以直接在终端中使用 <code>kt</code> 命令调用我们的应用程序了！\o/</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kt -V</span><br><span class="line">kt 0.1.0</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们创建了一个仅有数行 Rust 代码的命令行小工具，它接受一个文件路径作为输入，并在 <code>stdout</code> 中显示该文件的内容。</p>
<p>你可以在这个 <a href="https://github.com/jveillet/kt-rs" target="_blank" rel="noopener">GitHub 仓库</a>中找到这篇文章中的所有源代码。</p>
<p>轮到你来改进这个工具了！</p>
<ul>
<li>你可以添加一个命令行参数来控制是否在输出中添加行号（<code>-n</code> 选项）。</li>
<li>只显示文件的一部分，然后通过按键盘上的 <code>ENTER</code> 键来显示其余部分。</li>
<li>使用 <code>kt myfile.txt myfile2.txt myfile3.txt</code> 这样的语法一次性打开多个文件。</li>
</ul>
<p>不要犹豫，告诉我你用它做了什么！😎</p>
<p><strong>特别感谢帮助修订这篇文章的 Anaïs</strong> 👍</p>
<h2 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Cat_(Unix)" target="_blank" rel="noopener">cat</a>：cat 实用程序的 Wikipedia 页面。</li>
<li><a href="https://github.com/jveillet/kt-rs" target="_blank" rel="noopener">kt-rs</a></li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/" target="_blank" rel="noopener">Rust Cookbook</a></li>
<li><a href="https://github.com/clap-rs/clap" target="_blank" rel="noopener">Clap</a>：一个功能齐全、高性能的 Rust 命令行参数解析器。</li>
<li><a href="https://github.com/seanmonstar/reqwest" target="_blank" rel="noopener">Reqwest</a>：一个简单而功能强大的 Rust HTTP 客户端。</li>
<li><a href="https://github.com/serde-rs/serde" target="_blank" rel="noopener">Serde</a>：一个 Rust 的序列化框架。</li>
<li><a href="https://crates.io/" target="_blank" rel="noopener">crates.io</a>: Rust 社区的工具注册站点。</li>
</ul>
<blockquote>
<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p>
</blockquote>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019-03-02-how-to-build-your-own-neural-network-from-scratch-in-python/" itemprop="url">【译】如何用 Python 从零开始构建你自己的神经网络</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-03-02T02:34:00.000Z" itemprop="datePublished">3月 2 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            18 分钟 读完 (约 2651 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<ul>
<li>原文地址：<a href="https://towardsdatascience.com/how-to-build-your-own-neural-network-from-scratch-in-python-68998a08e4f6" target="_blank" rel="noopener">How to build your own Neural Network from scratch in Python</a></li>
<li>原文作者：<a href="https://towardsdatascience.com/@jamesloyys" target="_blank" rel="noopener">James Loy</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/how-to-build-your-own-neural-network-from-scratch-in-python.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/how-to-build-your-own-neural-network-from-scratch-in-python.md</a></li>
<li>译者：<a href="https://github.com/JackEggie" target="_blank" rel="noopener">JackEggie</a></li>
<li>校对者：<a href="https://github.com/lsvih" target="_blank" rel="noopener">lsvih</a>, <a href="https://github.com/xionglong58" target="_blank" rel="noopener">xionglong58</a></li>
</ul>
</blockquote>
<h1 id="如何用-Python-从零开始构建你自己的神经网络"><a href="#如何用-Python-从零开始构建你自己的神经网络" class="headerlink" title="如何用 Python 从零开始构建你自己的神经网络"></a>如何用 Python 从零开始构建你自己的神经网络</h1><blockquote>
<p>一个帮助初学者理解深度神经网络内部工作机制的指南</p>
</blockquote>
<p><strong>写作动机：</strong> 为了使我自己可以更好地理解深度学习，我决定在没有像 TensorFlow 这样的深度学习库的情况下，从零开始构建一个神经网络。我相信，理解神经网络的内部工作原理对任何有追求的数据科学家来说都很重要。</p>
<p>这篇文章包含了我所学到的东西，希望对你们也有用。</p>
<h2 id="什么是神经网络？"><a href="#什么是神经网络？" class="headerlink" title="什么是神经网络？"></a>什么是神经网络？</h2><p>大多数介绍神经网络的文章在描述它们时都会与大脑做类比。在不深入研究与大脑类似之处的情况下，我发现将神经网络简单地描述为给定输入映射到期望输出的数学函数更容易理解一些。</p>
<p>神经网络由以下几个部分组成：</p>
<ul>
<li>一个<strong>输入层</strong>，<strong><em>x</em></strong></li>
<li>任意数量的<strong>隐含层</strong></li>
<li>一个<strong>输出层</strong>，<strong><em>ŷ</em></strong></li>
<li>层与层之间的一组<strong>权重</strong>和<strong>偏差</strong>，<strong><em>W</em> 和 <em>b</em></strong></li>
<li>每个隐含层中所包含的一个可选的<strong>激活函数</strong>，<strong><em>σ</em></strong>。在本教程中，我们将使用 Sigmoid 激活函数。</li>
</ul>
<p>下图展示了 2 层神经网络的架构（<strong>注：在计算神经网络中的层数时，输入层通常被排除在外</strong>）</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*sX6T0Y4aa3ARh7IBS_sdqw.png" alt=""></p>
<p>2 层神经网络的架构</p>
<p>在 Python 中创建一个神经网络的类很简单。</p>
<p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NeuralNetwork</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x, y)</span>:</span></span><br><span class="line">        self.input      = x</span><br><span class="line">        self.weights1   = np.random.rand(self.input.shape[<span class="hljs-number">1</span>],<span class="hljs-number">4</span>) </span><br><span class="line">        self.weights2   = np.random.rand(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>)                 </span><br><span class="line">        self.y          = y</span><br><span class="line">        self.output     = np.zeros(y.shape)</span><br></pre></td></tr></table></figure></p>
<p><strong>训练神经网络</strong></p>
<p>一个简单的 2 层神经网络的输出 <strong><em>ŷ</em></strong> 如下：</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*E1_l8PGamc2xTNS87XGNcA.png" alt=""></p>
<p>你可能注意到了，在上面的等式中，只有权重 <strong><em>W</em></strong> 和偏差 <strong><em>b</em></strong> 这两个变量会对输出 <strong><em>ŷ</em></strong> 产生影响。</p>
<p>当然，合理的权重和偏差会决定预测的准确程度。将针对输入数据的权重和偏差进行微调的过程就是<strong>训练神经网络</strong>的过程。</p>
<p>训练过程的每次迭代包括以下步骤：</p>
<ul>
<li>计算预测输出的值 <strong><em>ŷ</em></strong>，即<strong>前馈</strong></li>
<li>更新权重和偏差，即<strong>反向传播</strong></li>
</ul>
<p>下面的序列图展示了这个过程。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*CEtt0h8Rss_qPu7CyqMTdQ.png" alt=""></p>
<h3 id="前馈过程"><a href="#前馈过程" class="headerlink" title="前馈过程"></a>前馈过程</h3><p>正如我们在上面的序列图中看到的，前馈只是一个简单的计算过程，对于一个基本的 2 层神经网络，它的输出是：</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*E1_l8PGamc2xTNS87XGNcA.png" alt=""></p>
<p>让我们在 Python 代码中添加一个前馈函数来实现这一点。注意，为了简单起见，我们假设偏差为 0。</p>
<p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NeuralNetwork</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x, y)</span>:</span></span><br><span class="line">        self.input      = x</span><br><span class="line">        self.weights1   = np.random.rand(self.input.shape[<span class="hljs-number">1</span>],<span class="hljs-number">4</span>) </span><br><span class="line">        self.weights2   = np.random.rand(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>)                 </span><br><span class="line">        self.y          = y</span><br><span class="line">        self.output     = np.zeros(self.y.shape)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">feedforward</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.layer1 = sigmoid(np.dot(self.input, self.weights1))</span><br><span class="line">        self.output = sigmoid(np.dot(self.layer1, self.weights2))</span><br></pre></td></tr></table></figure></p>
<p>但是，我们仍然需要一种方法来评估预测的“精准程度”（即我们的预测有多好）？而<strong>损失函数</strong>能让我们做到这一点。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>可用的损失函数有很多，而我们对损失函数的选择应该由问题本身的性质决定。在本教程中，我们将使用简单的<strong>平方和误差</strong>作为我们的损失函数。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*iNa1VLdaeqwUAxpNXs3jwQ.png" alt=""></p>
<p>这就是说，平方和误差只是每个预测值与实际值之差的总和。我们将差值平方后再计算，以便我们评估误差的绝对值。</p>
<p><strong>训练的目标是找到能使损失函数最小化的一组最优的权值和偏差。</strong></p>
<h3 id="反向传播过程"><a href="#反向传播过程" class="headerlink" title="反向传播过程"></a>反向传播过程</h3><p>现在我们已经得出了预测的误差（损失），我们还需要找到一种方法将误差<strong>传播</strong>回来，并更新我们的权重和偏差。</p>
<p>为了得出调整权重和偏差的合适的量，我们需要计算<strong>损失函数对于权重和偏差的导数</strong>。</p>
<p>回忆一下微积分的知识，计算函数的导数就是计算函数的斜率。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*3FgDOt4kJxK2QZlb9T0cpg.png" alt=""></p>
<p>梯度下降算法</p>
<p>如果我们已经算出了导数，我们就可以简单地通过增大/减小导数来更新权重和偏差（参见上图）。这就是所谓的<strong>梯度下降</strong>。</p>
<p>然而，我们无法直接计算损失函数对于权重和偏差的导数，因为损失函数的等式中不包含权重和偏差。 因此，我们需要<strong>链式法则</strong>来帮助我们进行计算。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*7zxb2lfWWKaVxnmq2o69Mw.png" alt=""></p>
<p>为了更新权重使用链式法则求解函数的导数。注意，为了简单起见，我们只展示了假设为 1 层的神经网络的偏导数。</p>
<p>哦！这真难看，但它让我们得到了我们需要的东西 —— 损失函数对于权重的导数（斜率），这样我们就可以相应地调整权重。</p>
<p>现在我们知道要怎么做了，让我们向 Pyhton 代码中添加反向传播函数。</p>
<p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NeuralNetwork</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x, y)</span>:</span></span><br><span class="line">        self.input      = x</span><br><span class="line">        self.weights1   = np.random.rand(self.input.shape[<span class="hljs-number">1</span>],<span class="hljs-number">4</span>) </span><br><span class="line">        self.weights2   = np.random.rand(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>)                 </span><br><span class="line">        self.y          = y</span><br><span class="line">        self.output     = np.zeros(self.y.shape)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">feedforward</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.layer1 = sigmoid(np.dot(self.input, self.weights1))</span><br><span class="line">        self.output = sigmoid(np.dot(self.layer1, self.weights2))</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backprop</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># 应用链式法则求出损失函数对于 weights2 和 weights1 的导数</span></span><br><span class="line">        d_weights2 = np.dot(self.layer1.T, (<span class="hljs-number">2</span>*(self.y - self.output) * sigmoid_derivative(self.output)))</span><br><span class="line">        d_weights1 = np.dot(self.input.T,  (np.dot(<span class="hljs-number">2</span>*(self.y - self.output) * sigmoid_derivative(self.output), self.weights2.T) * sigmoid_derivative(self.layer1)))</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># 用损失函数的导数(斜率)更新权重</span></span><br><span class="line">        self.weights1 += d_weights1</span><br><span class="line">        self.weights2 += d_weights2</span><br></pre></td></tr></table></figure></p>
<p>如果你需要更深入地理解微积分和链式法则在反向传播中的应用，我强烈推荐 3Blue1Brown 的教程。</p>
<p>观看<a href="https://youtu.be/tIeHLnjs5U8" target="_blank" rel="noopener">视频教程</a></p>
<h2 id="融会贯通"><a href="#融会贯通" class="headerlink" title="融会贯通"></a>融会贯通</h2><p>现在我们已经有了前馈和反向传播的完整 Python 代码，让我们将神经网络应用到一个示例中，看看效果如何。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*HaC4iILh2t0oOKi6S6FwtA.png" alt=""></p>
<p>我们的神经网络应该通过学习得出一组理想的权重来表示这个函数。请注意，仅仅是求解权重的过程对我们来说也并不简单。</p>
<p>让我们对神经网络进行 1500 次训练迭代，看看会发生什么。观察下图中每次迭代的损失变化，我们可以清楚地看到损失<strong>单调递减至最小值</strong>。这与我们前面讨论的梯度下降算法是一致的。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*fWNNA2YbsLSoA104K3Z3RA.png" alt=""></p>
<p>让我们看一下经过 1500 次迭代后神经网络的最终预测（输出）。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*9oOlYhhOSdCUqUJ0dQ_KxA.png" alt=""></p>
<p>1500 次训练迭代后的预测结果</p>
<p>我们成功了！我们的前馈和反向传播算法成功地训练了神经网络，预测结果收敛于真实值。</p>
<p>请注意，预测值和实际值之间会存在细微的偏差。我们需要这种偏差，因为它可以防止<strong>过拟合</strong>，并允许神经网络更好地<strong>推广</strong>至不可见数据中。</p>
<h2 id="后续的学习任务"><a href="#后续的学习任务" class="headerlink" title="后续的学习任务"></a>后续的学习任务</h2><p>幸运的是，我们的学习旅程还未结束。关于神经网络和深度学习，我们还有<strong>很多</strong>内容需要学习。例如：</p>
<ul>
<li>除了 Sigmoid 函数，我们还可以使用哪些<strong>激活函数</strong>？</li>
<li>在训练神经网络时使用<strong>学习率</strong></li>
<li>使用<strong>卷积</strong>进行图像分类任务</li>
</ul>
<p>我将会就这些主题编写更多内容，请在 Medium 上关注我并留意更新！</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>当然，我也在从零开始编写我自己的神经网络的过程中学到了很多。</p>
<p>虽然像 TensorFlow 和 Keras 这样的深度学习库使得构建深度神经网络变得很简单，即使你不完全理解神经网络内部工作原理也没关系，但是我发现对于有追求的数据科学家来说，深入理解神经网络是很有好处的。</p>
<p>这个练习花费了我大量的时间，我希望它对你们也有帮助！</p>
<blockquote>
<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p>
</blockquote>

    
    </div>
    
    
</article>




    
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Jack Tang&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/JackEggie" target="_blank" rel="noopener">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/" target="_blank" rel="noopener">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>