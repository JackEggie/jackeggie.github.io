<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jackeggie.github.io/"/>
  <updated>2019-10-31T06:16:22.553Z</updated>
  <id>http://jackeggie.github.io/</id>
  
  <author>
    <name>Jack Tang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】Go 语言概览</title>
    <link href="http://jackeggie.github.io/2019-07-25-a-bird-s-eye-view-of-go/"/>
    <id>http://jackeggie.github.io/2019-07-25-a-bird-s-eye-view-of-go/</id>
    <published>2019-07-25T10:49:21.000Z</published>
    <updated>2019-10-31T06:16:22.553Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://blog.merovius.de/2019/06/12/birdseye-go.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A bird’s eye view of Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;https://blog.merovius.de&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Axel Wagner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/birdseye-go.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xitu/gold-miner/blob/master/TODO1/birdseye-go.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/JackEggie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JackEggie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/40m41h42t&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;40m41h42t&lt;/a&gt;, &lt;a href=&quot;https://github.com/JalanJiang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JalanJiang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Go-语言概览&quot;&gt;&lt;a href=&quot;#Go-语言概览&quot; class=&quot;headerlink&quot; title=&quot;Go 语言概览&quot;&gt;&lt;/a&gt;Go 语言概览&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;本文摘要：本文非常笼统地总结了 Go 语言的定义、生态系统和实现方式，也尽力给出了与不同的需求所对应的参考文档，详情参见本文末尾。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每当我们说起“Go 语言”的时候，可能会因为场景的不同聊到很多完全不同的东西。因此，我尝试着对 Go 语言和其生态系统做一个概述，并在各部分内容中都列出相关的文档（这可能有点像是大杂烩，其中还包含了我最近实际遇到的许多问题）。让我们开始吧：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="gold-miner" scheme="http://jackeggie.github.io/tags/gold-miner/"/>
    
      <category term="translation" scheme="http://jackeggie.github.io/tags/translation/"/>
    
      <category term="go-lang" scheme="http://jackeggie.github.io/tags/go-lang/"/>
    
  </entry>
  
  <entry>
    <title>Java 中 int 类型的二进制表示</title>
    <link href="http://jackeggie.github.io/2019-07-21-binary-form-of-int-in-java/"/>
    <id>http://jackeggie.github.io/2019-07-21-binary-form-of-int-in-java/</id>
    <published>2019-07-21T09:55:51.000Z</published>
    <updated>2019-10-31T06:19:25.215Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;可通过 Integer.MAX_VALUE 和 Integer.MIN_VALUE 查看 int 类型的最大和最小值，分别为 0x7fffffff(2^31-1) 和 0x80000000(2^31)，其中 0 即为 0，正数的最高位为 0，负数的最高位为 1。&lt;/p&gt;
&lt;p&gt;Java 中负数的表示方式为正数的补码（例：原码 00，反码 11，补码 00，补码的计算方式为反码加一，此处丢弃溢出位）。采用这种方式的原因是 0 的交叉（zero crossing）问题，即 0 和 -0 需要用同一种方式表示，见补码计算例子。如果采用反码表示负数的话，0 就会有两种表示：所有位全为 0、所有位全为 1。&lt;/p&gt;
&lt;p&gt;因此 Java 中 0 的所有位全为 0，1 为 0000…0001，-1 的所有位全为 1，Integer.MAX_VALUE 为 0111…1111，Integer.MIN_VALUE 为 1000…0000。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://jackeggie.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【译】我们从招聘技术经理的过程中学到了什么</title>
    <link href="http://jackeggie.github.io/2019-05-16-what-we-ve-learned-about-hiring-engineering-managers/"/>
    <id>http://jackeggie.github.io/2019-05-16-what-we-ve-learned-about-hiring-engineering-managers/</id>
    <published>2019-05-16T05:32:55.000Z</published>
    <updated>2019-10-31T06:19:25.120Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://circleci.com/blog/what-we-ve-learned-about-hiring-engineering-managers/?utm_source=cooperpress&amp;utm_medium=newsletter&amp;utm_campaign=feb19&amp;utm_content=javascript-weekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What we’ve learned about hiring engineering managers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;https://twitter.com/lrnrd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lena Reinhard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/what-we-ve-learned-about-hiring-engineering-managers.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xitu/gold-miner/blob/master/TODO1/what-we-ve-learned-about-hiring-engineering-managers.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/JackEggie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JackEggie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/portandbridge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;portandbridge&lt;/a&gt;, &lt;a href=&quot;https://github.com/Baddyo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Baddyo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;我们从招聘技术经理的过程中学到了什么&quot;&gt;&lt;a href=&quot;#我们从招聘技术经理的过程中学到了什么&quot; class=&quot;headerlink&quot; title=&quot;我们从招聘技术经理的过程中学到了什么&quot;&gt;&lt;/a&gt;我们从招聘技术经理的过程中学到了什么&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://circleci.com/blog/media/EngineeringManagers.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在过去的一年里，我们对于理解负责 CircleCI 的技术经理所需的优秀品质有了重要的转变，并从中了解到我们作为一个组织的需求和价值观。我们大幅改变了招聘流程，通过这些努力，我们聘用了一些出色的人才，使我们技术管理团队的人数翻了一番。现在，我们想和大家分享这些经验。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="gold-miner" scheme="http://jackeggie.github.io/tags/gold-miner/"/>
    
      <category term="translation" scheme="http://jackeggie.github.io/tags/translation/"/>
    
      <category term="management" scheme="http://jackeggie.github.io/tags/management/"/>
    
  </entry>
  
  <entry>
    <title>【译】Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分</title>
    <link href="http://jackeggie.github.io/2019-05-04-distributed-transactions-in-spring-with-and-without-xa-part-1/"/>
    <id>http://jackeggie.github.io/2019-05-04-distributed-transactions-in-spring-with-and-without-xa-part-1/</id>
    <published>2019-05-04T02:24:09.000Z</published>
    <updated>2019-10-31T06:19:25.253Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://www.javaworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Distributed transactions in Spring, with and without XA - Part I&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;mailto:david.syer@springsource.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Syer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-1.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-1.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/JackEggie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JackEggie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/fireairforce&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fireairforce&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Spring-的分布式事务实现-—-使用和不使用-XA-—-第一部分&quot;&gt;&lt;a href=&quot;#Spring-的分布式事务实现-—-使用和不使用-XA-—-第一部分&quot; class=&quot;headerlink&quot; title=&quot;Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分&quot;&gt;&lt;/a&gt;Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-1.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring 的分布式事务实现 — 使用和不使用 XA — 第一部分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-2.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring 的分布式事务实现 — 使用和不使用 XA — 第二部分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/distributed-transactions-in-spring-with-and-without-xa-part-3.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring 的分布式事务实现 — 使用和不使用 XA — 第三部分&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring 的 7 种事务处理模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然在 Spring 中分布式事务通常使用 Java Transaction API 和 XA 协议实现，但也有其他的实现方式。最好的实现方式取决于应用程序所使用资源的类型，以及你是否愿意在性能、安全性、可靠性和数据完整性之间做出权衡。针对这个 Java 中的典型问题，Spring 的开发者 David Syer 将会介绍 7 种 Spring 分布式应用的实现方式，其中 3 种实现使用了 XA 协议，另外 4 种使用了其他的实现方式。（中级知识点）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="gold-miner" scheme="http://jackeggie.github.io/tags/gold-miner/"/>
    
      <category term="translation" scheme="http://jackeggie.github.io/tags/translation/"/>
    
      <category term="spring" scheme="http://jackeggie.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>聊聊我的第一次心理咨询体验</title>
    <link href="http://jackeggie.github.io/2019-04-22-my-first-psychological-counseling/"/>
    <id>http://jackeggie.github.io/2019-04-22-my-first-psychological-counseling/</id>
    <published>2019-04-22T05:01:04.000Z</published>
    <updated>2019-10-31T06:19:25.276Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;从去年开始筹备婚礼之后，自己的情绪就变得逐渐“难以控制”起来。在以前，即使偶尔和父母有矛盾，也仅仅只是不开心，很少有能够影响好几天的情况发生。而现在，一旦因为某些事情不顺心，可以被悲观的情绪影响好多天。被消极的想法支配的感觉真的很不好。&lt;/p&gt;
&lt;p&gt;在被悲观情绪支配的情况愈演愈烈之后，我极度想要做出一些改变。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="psychology" scheme="http://jackeggie.github.io/tags/psychology/"/>
    
  </entry>
  
  <entry>
    <title>【译】用 Rust 打造你的第一个命令行工具</title>
    <link href="http://jackeggie.github.io/2019-04-14-your-first-cli-tool-with-rust/"/>
    <id>http://jackeggie.github.io/2019-04-14-your-first-cli-tool-with-rust/</id>
    <published>2019-04-14T02:40:13.000Z</published>
    <updated>2019-10-31T06:19:25.238Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://www.demainilpleut.fr/your-first-cli-tool-with-rust/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Your first CLI tool with Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;https://www.demainilpleut.fr/authors/jveillet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jérémie Veillet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/your-first-cli-tool-with-rust.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xitu/gold-miner/blob/master/TODO1/your-first-cli-tool-with-rust.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/JackEggie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JackEggie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/TloveYing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TloveYing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;用-Rust-打造你的第一个命令行工具&quot;&gt;&lt;a href=&quot;#用-Rust-打造你的第一个命令行工具&quot; class=&quot;headerlink&quot; title=&quot;用 Rust 打造你的第一个命令行工具&quot;&gt;&lt;/a&gt;用 Rust 打造你的第一个命令行工具&lt;/h1&gt;&lt;p&gt;在精彩的编程世界里，你可能听说过这种名为 Rust 的新语言。它是一种开源的系统级编程语言。它专注于性能、内存安全和并行性。你可以像 C/C++ 那样用它编写底层应用程序。&lt;/p&gt;
&lt;p&gt;你可能已经在 &lt;a href=&quot;https://webassembly.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web Assembly&lt;/a&gt; 网站上见到过它了。Rust 能够编译 WASM 应用程序，你可以在 &lt;a href=&quot;https://webassembly.org/docs/use-cases/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web Assembly FAQ&lt;/a&gt; 上找到很多例子。它也被认为是 &lt;a href=&quot;https://servo.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;servo&lt;/a&gt; 的基石，servo 是一个在 Firefox 中实现的高性能浏览器引擎。&lt;/p&gt;
&lt;p&gt;这可能会让你望而却步，但这不是我们要在这里讨论的内容。我们将介绍如何使用它构建命令行工具，而你可能会从中发现很多有意思的东西。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="gold-miner" scheme="http://jackeggie.github.io/tags/gold-miner/"/>
    
      <category term="translation" scheme="http://jackeggie.github.io/tags/translation/"/>
    
      <category term="rust" scheme="http://jackeggie.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>【译】如何用 Python 从零开始构建你自己的神经网络</title>
    <link href="http://jackeggie.github.io/2019-03-02-how-to-build-your-own-neural-network-from-scratch-in-python/"/>
    <id>http://jackeggie.github.io/2019-03-02-how-to-build-your-own-neural-network-from-scratch-in-python/</id>
    <published>2019-03-02T02:34:00.000Z</published>
    <updated>2019-10-31T06:19:25.156Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://towardsdatascience.com/how-to-build-your-own-neural-network-from-scratch-in-python-68998a08e4f6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to build your own Neural Network from scratch in Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;https://towardsdatascience.com/@jamesloyys&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;James Loy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/how-to-build-your-own-neural-network-from-scratch-in-python.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xitu/gold-miner/blob/master/TODO1/how-to-build-your-own-neural-network-from-scratch-in-python.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/JackEggie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JackEggie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/lsvih&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lsvih&lt;/a&gt;, &lt;a href=&quot;https://github.com/xionglong58&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xionglong58&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;如何用-Python-从零开始构建你自己的神经网络&quot;&gt;&lt;a href=&quot;#如何用-Python-从零开始构建你自己的神经网络&quot; class=&quot;headerlink&quot; title=&quot;如何用 Python 从零开始构建你自己的神经网络&quot;&gt;&lt;/a&gt;如何用 Python 从零开始构建你自己的神经网络&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一个帮助初学者理解深度神经网络内部工作机制的指南&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;写作动机：&lt;/strong&gt; 为了使我自己可以更好地理解深度学习，我决定在没有像 TensorFlow 这样的深度学习库的情况下，从零开始构建一个神经网络。我相信，理解神经网络的内部工作原理对任何有追求的数据科学家来说都很重要。&lt;/p&gt;
&lt;p&gt;这篇文章包含了我所学到的东西，希望对你们也有用。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="gold-miner" scheme="http://jackeggie.github.io/tags/gold-miner/"/>
    
      <category term="translation" scheme="http://jackeggie.github.io/tags/translation/"/>
    
      <category term="python" scheme="http://jackeggie.github.io/tags/python/"/>
    
      <category term="ai" scheme="http://jackeggie.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>Java 中的双重检查锁(Double-Checked Locking)的问题</title>
    <link href="http://jackeggie.github.io/2018-10-08-talk-about-double-locking-problem/"/>
    <id>http://jackeggie.github.io/2018-10-08-talk-about-double-locking-problem/</id>
    <published>2018-10-08T05:22:54.000Z</published>
    <updated>2019-10-31T06:19:25.011Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-中的双重检查锁&quot;&gt;&lt;a href=&quot;#Java-中的双重检查锁&quot; class=&quot;headerlink&quot; title=&quot;Java 中的双重检查锁&quot;&gt;&lt;/a&gt;Java 中的双重检查锁&lt;/h3&gt;&lt;p&gt;不知道从什么时候开始，双重锁检机制开始在 Java 程序员中流传开来，并被一些不成熟的程序员所称道。然而，双重锁检机制无论在 Java 的什么年代，都是一个不折不扣的代码陷阱。&lt;/p&gt;
&lt;p&gt;&lt;epacse hidden&gt;24&lt;/epacse&gt;&lt;/p&gt;
&lt;p&gt;这段代码粗看上去使用了很“神奇”的 Java 多线程技巧，“巧妙”利用重复地两次检查对象是否为空来避免了大部分情况下 synchronized 关键字的性能消耗。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="jvm" scheme="http://jackeggie.github.io/tags/jvm/"/>
    
      <category term="multi-thread" scheme="http://jackeggie.github.io/tags/multi-thread/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎技术的简介</title>
    <link href="http://jackeggie.github.io/2018-05-17-intro-to-search-engine/"/>
    <id>http://jackeggie.github.io/2018-05-17-intro-to-search-engine/</id>
    <published>2018-05-17T05:20:34.000Z</published>
    <updated>2019-10-31T06:19:25.185Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是搜索引擎？&quot;&gt;&lt;a href=&quot;#什么是搜索引擎？&quot; class=&quot;headerlink&quot; title=&quot;什么是搜索引擎？&quot;&gt;&lt;/a&gt;什么是搜索引擎？&lt;/h3&gt;&lt;h4 id=&quot;日常生活中的搜索引擎&quot;&gt;&lt;a href=&quot;#日常生活中的搜索引擎&quot; class=&quot;headerlink&quot; title=&quot;日常生活中的搜索引擎&quot;&gt;&lt;/a&gt;日常生活中的搜索引擎&lt;/h4&gt;&lt;p&gt;搜索引擎是一种用来在互联网上搜索信息的应用程序。当然，现在说是应用程序已经不太确切了，称为服务会更准确一些。像 Google、Baidu 等互联网搜索引擎人们都已经习以为常。通过搜索引擎，人们可以很轻松方便地从网络上查找到自己需要的资源，很难以想象没有搜索引擎的时代人们需要怎样去获取信息。&lt;/p&gt;
&lt;h4 id=&quot;搜索引擎-VS-数据库&quot;&gt;&lt;a href=&quot;#搜索引擎-VS-数据库&quot; class=&quot;headerlink&quot; title=&quot;搜索引擎 VS 数据库&quot;&gt;&lt;/a&gt;搜索引擎 VS 数据库&lt;/h4&gt;&lt;p&gt;同样提供存储和查询功能，但是搜索引擎和数据库在设计理念和工作方式上差异还是非常大的。数据库的功能更为的全面，是一种通用的数据存取引擎，搜索引擎则重点处理大数据量的文本数据，并且只侧重于获取数据的性能和方式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="search engine" scheme="http://jackeggie.github.io/tags/search-engine/"/>
    
  </entry>
  
  <entry>
    <title>结构化一个页面的内容 - MDN html 作业</title>
    <link href="http://jackeggie.github.io/2018-04-28-structuring-a-page-of-content/"/>
    <id>http://jackeggie.github.io/2018-04-28-structuring-a-page-of-content/</id>
    <published>2018-04-28T06:03:24.000Z</published>
    <updated>2019-10-31T06:19:24.988Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文将会解析来自MDN web docs的一份html作业，内容较为基础，有一定html知识的同学可以选择绕道。&lt;/p&gt;
&lt;h3 id=&quot;作业描述&quot;&gt;&lt;a href=&quot;#作业描述&quot; class=&quot;headerlink&quot; title=&quot;作业描述&quot;&gt;&lt;/a&gt;作业描述&lt;/h3&gt;&lt;p&gt;作业地址：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Structuring_a_page_of_content&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;结构化一个页面的内容&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将上述页面提供的html文件加上结构化标签，使应用于结构化标签的css生效。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="html" scheme="http://jackeggie.github.io/tags/html/"/>
    
      <category term="frontend" scheme="http://jackeggie.github.io/tags/frontend/"/>
    
  </entry>
  
  <entry>
    <title>标记一封信 - MDN html 作业</title>
    <link href="http://jackeggie.github.io/2018-04-21-marking-up-a-letter/"/>
    <id>http://jackeggie.github.io/2018-04-21-marking-up-a-letter/</id>
    <published>2018-04-21T02:02:18.000Z</published>
    <updated>2019-10-31T06:19:25.338Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文将会解析来自MDN web docs的一份html作业，内容较为基础，有一定html知识的同学可以选择绕道。&lt;/p&gt;
&lt;h3 id=&quot;作业描述&quot;&gt;&lt;a href=&quot;#作业描述&quot; class=&quot;headerlink&quot; title=&quot;作业描述&quot;&gt;&lt;/a&gt;作业描述&lt;/h3&gt;&lt;p&gt;作业地址：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Marking_up_a_letter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;标记一封信&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将上述页面提供的一封信进行合适的html标记，使其成为一封传统的信件的格式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="html" scheme="http://jackeggie.github.io/tags/html/"/>
    
      <category term="frontend" scheme="http://jackeggie.github.io/tags/frontend/"/>
    
  </entry>
  
  <entry>
    <title>本博客升级过程</title>
    <link href="http://jackeggie.github.io/2018-04-14-upgrade-hexo-and-next/"/>
    <id>http://jackeggie.github.io/2018-04-14-upgrade-hexo-and-next/</id>
    <published>2018-04-14T08:52:37.000Z</published>
    <updated>2019-10-31T06:19:25.032Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文主要描述Hexo相关组件的升级方式和Next主题的升级方式。&lt;/p&gt;
&lt;h3 id=&quot;Hexo升级&quot;&gt;&lt;a href=&quot;#Hexo升级&quot; class=&quot;headerlink&quot; title=&quot;Hexo升级&quot;&gt;&lt;/a&gt;Hexo升级&lt;/h3&gt;&lt;p&gt;本以为会比较复杂，其实非常简单，一条命令就能搞定。&lt;/p&gt;
&lt;p&gt;&lt;epacse hidden&gt;26&lt;/epacse&gt;&lt;/p&gt;
&lt;p&gt;这里解释一下这个命令的含义。npm是javascript的管理依赖的工具，会随着node.js一起安装。通过npm工具可以安装、更新、删除依赖，上面列出的命令即可以更新当前项目下的所有依赖。另外所有的依赖版本信息都会存储在项目的package.json中，可以直接到该文件中去查看依赖的版本是否是最新的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://jackeggie.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>缓存框架调研</title>
    <link href="http://jackeggie.github.io/2018-04-07-cache-framework-research/"/>
    <id>http://jackeggie.github.io/2018-04-07-cache-framework-research/</id>
    <published>2018-04-07T08:33:33.000Z</published>
    <updated>2019-10-31T06:19:24.999Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h3&gt;&lt;p&gt;简介：结构化数据存储服务。由客户端提供一系列api（command）来访问数据。支持分布式存储。&lt;/p&gt;
&lt;p&gt;开源：C语言&lt;/p&gt;
&lt;p&gt;jsr107：不支持&lt;/p&gt;
&lt;p&gt;ssl加密：支持&lt;/p&gt;
&lt;p&gt;sql查询：&lt;a href=&quot;https://github.com/RedBeardLab/rediSQL&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;rediSQL&lt;/a&gt; – 500+ stars&lt;/p&gt;
&lt;p&gt;事务：MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。&lt;/p&gt;
&lt;p&gt;数据分区：固定为16384个slot&lt;/p&gt;
&lt;p&gt;java原生数据类型：redis只支持自己提供的数据类型，String，Hash，Set，List，Zset&lt;/p&gt;
&lt;p&gt;二级缓存支持：不支持&lt;/p&gt;
&lt;p&gt;事件通知：publish、subscribe命令&lt;/p&gt;
&lt;p&gt;持久化：rdb、aof&lt;/p&gt;
&lt;p&gt;客户端api：jedis、redisson&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="cache" scheme="http://jackeggie.github.io/tags/cache/"/>
    
      <category term="redis" scheme="http://jackeggie.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>浮躁、静不下心的解决方案</title>
    <link href="http://jackeggie.github.io/2018-03-31-fickleness/"/>
    <id>http://jackeggie.github.io/2018-03-31-fickleness/</id>
    <published>2018-03-31T10:07:32.000Z</published>
    <updated>2019-10-31T06:19:25.327Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近临近离职，空闲的时间比较多，但是也还是不知道如何静下心来去做一些一直都想去完成的事情。思考后的结果就是觉得太过于浮躁，需要改变些什么才能有动力去做，既然改变本身就是一种动力，那么就要思考一下怎么去改变了。&lt;/p&gt;
&lt;h3 id=&quot;浮躁的来源&quot;&gt;&lt;a href=&quot;#浮躁的来源&quot; class=&quot;headerlink&quot; title=&quot;浮躁的来源&quot;&gt;&lt;/a&gt;浮躁的来源&lt;/h3&gt;&lt;p&gt;从人类本身的角度来看，奖励机制的过度使用才是浮躁的根本原因。这里的奖励机制就是小白鼠被点击后会产生多巴胺的机制。这种机制是感性的，被刺激到了就会觉得很开心，即使本身并没有什么意义。这种机制存在的意义是对人类的繁衍很有帮助，包括美食与性，都是这种奖励机制的正反馈。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="psychology" scheme="http://jackeggie.github.io/tags/psychology/"/>
    
      <category term="fickleness" scheme="http://jackeggie.github.io/tags/fickleness/"/>
    
  </entry>
  
  <entry>
    <title>Java内存结构</title>
    <link href="http://jackeggie.github.io/2018-03-24-java-memory-module/"/>
    <id>http://jackeggie.github.io/2018-03-24-java-memory-module/</id>
    <published>2018-03-24T07:43:07.000Z</published>
    <updated>2019-10-31T06:19:25.289Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Java内存模型是JVM与计算机内存协同工作的规范与准则。Java虚拟机中的线程与内存结构和计算机的CPU与主存的架构并不相同，因此才需要一套规则来整合两种模型来协同工作。&lt;/p&gt;
&lt;p&gt;这套规则描述了线程间共享变量的可见性和多线程访问带来的冲突等问题。&lt;/p&gt;
&lt;p&gt;原始的Java内存模型天生存在一些不足之处，因此在JDK1.5之后做了重新修订。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="jvm" scheme="http://jackeggie.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>对于情绪管理的思考</title>
    <link href="http://jackeggie.github.io/2018-03-17-emotion-management/"/>
    <id>http://jackeggie.github.io/2018-03-17-emotion-management/</id>
    <published>2018-03-17T09:32:24.000Z</published>
    <updated>2019-10-31T06:19:25.266Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一直以来，自己的情绪一直是个问题，很容易就大动肝火。不顾后果地发脾气很容易伤了身边的人又伤了自己。所以去找了一些资料，让自己学习如何管理自己的情绪。&lt;/p&gt;
&lt;h3 id=&quot;认识情绪&quot;&gt;&lt;a href=&quot;#认识情绪&quot; class=&quot;headerlink&quot; title=&quot;认识情绪&quot;&gt;&lt;/a&gt;认识情绪&lt;/h3&gt;&lt;p&gt;情绪这东西甚至说不上是个抽象的概念，大概连个具体的定义也没有吧。但是普通人还是很容易理解什么是情绪，什么是开心的情绪或者是不开心的情绪。这大概就是理科和文科学习上的区别。&lt;/p&gt;
&lt;p&gt;我们表露出来的情绪，需要我们自己去正视它，不要把情绪理解为好与坏。情绪本身没有好坏之分，只是人对外部世界的某些刺激做出的正常反应而已。也许有些同学已经明白了，情绪就是应激的一部分。&lt;/p&gt;
&lt;p&gt;有的人会选择压抑情绪，有的人则会选择宣泄情绪。但是其实能把情绪表露出来，也算是某种程度上的自由意志的体现。渴望自由的人会倾向于表达，而崇尚节律的人会倾向于抑制。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="psychology" scheme="http://jackeggie.github.io/tags/psychology/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="http://jackeggie.github.io/2018-03-10-jvm-memory-structure/"/>
    <id>http://jackeggie.github.io/2018-03-10-jvm-memory-structure/</id>
    <published>2018-03-10T08:42:27.000Z</published>
    <updated>2019-10-31T06:19:24.968Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构概述&quot;&gt;&lt;a href=&quot;#JVM内存结构概述&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构概述&quot;&gt;&lt;/a&gt;JVM内存结构概述&lt;/h3&gt;&lt;p&gt;在开发过程中经常会遇到的堆内存的概念具体是什么？常量池在JVM中的内存区域是怎么管理的？遇到OutOfMemory异常应该如何处理？&lt;/p&gt;
&lt;p&gt;平时对上述问题可能只有一个模糊的概念，本文将会详细地介绍JVM的内存结构，让上面问题的答案变得清晰明了。&lt;/p&gt;
&lt;p&gt;JVM的内存结构主要分为堆内存、方法区和栈三大块。而堆内存又分为新生代和老生代。方法区存储的信息为常量、类信息和静态变量等。栈分为程序计数器、JVM方法栈和本地方法栈。堆和方法区是线程共享的内存区域，而栈是线程的私有内存区域。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="jvm" scheme="http://jackeggie.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Scrum实践</title>
    <link href="http://jackeggie.github.io/2018-03-03-practice-scrum/"/>
    <id>http://jackeggie.github.io/2018-03-03-practice-scrum/</id>
    <published>2018-03-03T07:17:56.000Z</published>
    <updated>2019-10-31T06:19:25.227Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h3&gt;&lt;h4 id=&quot;Agile&quot;&gt;&lt;a href=&quot;#Agile&quot; class=&quot;headerlink&quot; title=&quot;Agile&quot;&gt;&lt;/a&gt;Agile&lt;/h4&gt;&lt;p&gt;敏捷的概念与瀑布模型是相对的，敏捷是一种以人为核心，不断迭代的技术团队管理方式。&lt;/p&gt;
&lt;h4 id=&quot;以人为核心&quot;&gt;&lt;a href=&quot;#以人为核心&quot; class=&quot;headerlink&quot; title=&quot;以人为核心&quot;&gt;&lt;/a&gt;以人为核心&lt;/h4&gt;&lt;p&gt;瀑布模型是以文档驱动的，而敏捷模式强调人与人之间的交流。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="agile" scheme="http://jackeggie.github.io/tags/agile/"/>
    
      <category term="scrum" scheme="http://jackeggie.github.io/tags/scrum/"/>
    
  </entry>
  
  <entry>
    <title>Json解析器性能对比</title>
    <link href="http://jackeggie.github.io/2018-02-24-json-parser-performance/"/>
    <id>http://jackeggie.github.io/2018-02-24-json-parser-performance/</id>
    <published>2018-02-24T07:31:19.000Z</published>
    <updated>2019-10-31T06:19:25.313Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在两年前曾经做过四种Json解析器的性能对比，现在回头看当时的结果，跟当时的想法还是有很大差异的。&lt;/p&gt;
&lt;h3 id=&quot;Json-lib、Gson、Jackson、Fastjson性能对比&quot;&gt;&lt;a href=&quot;#Json-lib、Gson、Jackson、Fastjson性能对比&quot; class=&quot;headerlink&quot; title=&quot;Json-lib、Gson、Jackson、Fastjson性能对比&quot;&gt;&lt;/a&gt;Json-lib、Gson、Jackson、Fastjson性能对比&lt;/h3&gt;&lt;p&gt;测试环境如下：&lt;/p&gt;
&lt;p&gt;&lt;epacse hidden&gt;18&lt;/epacse&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="json" scheme="http://jackeggie.github.io/tags/json/"/>
    
      <category term="performance" scheme="http://jackeggie.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="http://jackeggie.github.io/2018-02-17-string-search/"/>
    <id>http://jackeggie.github.io/2018-02-17-string-search/</id>
    <published>2018-02-17T08:12:48.000Z</published>
    <updated>2019-10-31T06:19:24.977Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h3&gt;&lt;p&gt;有一个长字符串string，现在需要在该字符串中查找到一个特定短字符串pattern，并返回其位置。&lt;/p&gt;
&lt;p&gt;上述问题为经典的字符串查找问题，这类问题数据算法的基础问题，应当熟记解决方法。&lt;/p&gt;
&lt;h3 id=&quot;Brute-Force算法&quot;&gt;&lt;a href=&quot;#Brute-Force算法&quot; class=&quot;headerlink&quot; title=&quot;Brute-Force算法&quot;&gt;&lt;/a&gt;Brute-Force算法&lt;/h3&gt;&lt;p&gt;最简单的方案就是分别对string和pattern的每个位置进行依次比较。这样就会产生两个循环体分别对string和pattern进行遍历，很容易得出时间复杂度为string长度的二次幂。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="http://jackeggie.github.io/tags/algorithm/"/>
    
  </entry>
  
</feed>
